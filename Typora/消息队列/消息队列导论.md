# 消息队列的使用场景

* 异步处理

* 流量控制

* **服务解耦：随着业务的发展，下游系统也在不断的增加，不断变化，使用消息队列可以将上下游系统解耦**

  > 当一个订单创建时：
  >
  > 1. 支付系统需要发起支付流程；
  > 2. 风控系统需要审核订单的合法性；
  > 3. 客服系统需要给用户发短信告知用户；
  > 4. 经营分析系统需要更新统计数据；
  >
  > 这些订单下游的系统都需要实时获得订单数据。随着业务不断发展，这些订单下游系统不断的增加，不断变化，并且每个系统可能只需要订单数据的一个子集，负责订单服务的开发团队不得不花费很大的精力，应对不断增加变化的下游系统，不停地修改调试订单系统与这些下游系统的接口。任何一个下游系统接口变更，都需要订单模块重新进行一次上线，对于一个电商的核心服务来说，这几乎是不可接受的。
  >
  > 所有的电商都选择用消息队列来解决类似的系统耦合过于紧密的问题。引入消息队列后，订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。
  >
  > 无论增加、减少下游系统或是下游系统需求如何变化，订单服务都无需做任何更改，实现了订单服务与下游服务的解耦。

# 消息模型

早期的消息队列，就是按照“队列”的数据结构来设计的。生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。

## 队列模型

![image-20211111214557119](https://raw.githubusercontent.com/syllr/image/main/uPic/202111112146013EhuKO.png)

* 如果有多个生产者往同一个队列里面发送消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者发送消息的自然顺序。

* 如果有多个消费者订阅同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到。

  > 如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息，例如，对于一份订单数据，风控系统，分析系统，支付系统等都需要接收消息，这个时候单个队列就满足不了了，**一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份。**
  >
  > 显然这是个比较蠢的做法，同样的一份消息数据被复制到多个队列中会浪费资源，更重要的是，生产者必须知道有多少个消费者。为每个消费者单独发送一份消息，这实际上违背了消息队列“解耦”这个设计初衷。

### RabbitMQ消息模型

![RabbitMQ架构图](https://raw.githubusercontent.com/syllr/image/main/uPic/202111140902179aqoPe.svg)

RabbitMQ的消息模型就是基于队列模型，添加了Exchange（交换机）的概念，

* 生产者将消息发送到Exchange，由交换器将消息路由到一个或者多个队列中，如果路由不到，或许返回给生产者，或许直接丢弃

  > RabbitMQ提供了不同种类的Exchange，这些Exchange有不同的路由规则

* 消费者或者消费者组订阅对应的队列进行消费

### 总结

* 结构简单，便于理解，消息队列和我们普通的数据结构中的队列是一样的，生产者生产消息就入队列，消费者消费消息就出队列

* 一个队列只能存放在一个节点中，不方便水平扩展，假如有

  * 两台服务器，服务器A，服务器B，两个队列，队列1，队列2，则队列1，队列2，最多只能分别的存放在不同的服务器节点中，队列1不可能把一部分数据存放在服务器A，把另一部分的数据存放在服务器B，实际上一个topic的所有消息都存放在一个服务器中，就算一个topic的数据大量堆积，也只能提供单机的消息收发能力（这也是RabbitMQ对消息堆积处理不好的原因）

  * 因为一个topic的所有消息都存放在一个队列中，可以方便的实现消息的顺序消费

    > 与之相对应的是Kafka和RocketMQ要实现顺序消费必须在生产者发送消息的时候指定分区或者consumeQueue

* 如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息（即广播模式），有以下两种做法

  * 为每个消费者创建一个单独的队列，让生产者发送多份（这种做法太蠢，而且生产者和消费者不能解耦）
  * 实时广播，队列中的消息还是只存一份，在broker中保存消费者和队列的订阅关系，发送的时候向多个消费者同时发送消息（Redis的发布订阅模式一样的逻辑），这种方式有以下几种缺陷
    * 如果消费者宕机或者下线，那么在消费者和broker断开连接这段时间内的消息将会丢失
    * broker向消费者发送消息的方式可以是同步的也可以是异步的
      1. 如果是同步的broker则需要等待所有的消费者都接收到消息之后才算发送成功，这样效率太低
      2. 如果是异步的broker向所有的消费者发送完消息之后不管消费者是否真的接收到消息，就算消费者没有宕机或者断开连接也会丢失消息

  > RabbitMQ采用的是实时广播+异步发送消息的方式来实现广播模式，所以RabbitMQ的广播模式是不支持持久化的，而且会丢失消息，与之相对应的RocketMQ的广播模式是每个消费者管理自己的消费进度，即使宕机也不会丢失消息

## 发布-订阅模型

![image-20211114152648898](https://raw.githubusercontent.com/syllr/image/main/uPic/20211114152650eplvNb.png)

在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。

发布订阅模式对比队列模式最主要的是消费者订阅的是“主题”，主题是一个抽象的概念，一个主题下面可以有多个队列，这样可以很方便的横向扩展

### RocketMQ消息模型

<img src="/Users/yutao/Library/Application Support/typora-user-images/image-20211114160014844.png" alt="image-20211114160014844" style="zoom:67%;" />

RocketMQ的一个主题下面可以有多个队列，一个主题的多个队列可以分布在不同的服务器节点上，

* 在集群模式下，一个队列只能同时让一个消费者消费（这一点和队列模型是一致的）因为一个主题有多个队列，所以一个主题可以同时让多个消费者同时消费，加快了消费速度
* 在广播模式下，同一个消费组的多个消费者可以同时消费同一个队列，一个主题中的所有队列都可以被并行的消费，加快了消费的速度

> RocketMQ消息模型对于RabbitMQ的消息模型最主要有两点的不同
>
> * 加入了主题的概念，一个主题中可以有多个队列
> * 使用offset来管理每个队列的消费进度，
>   * 集群模式下一个队列同一时间只能由一个消费者消费，所以集群模式下的offset可以由broker管理
>   * 广播模式下一个队列可以同时被多个消费者消费，所以每个消费者自己管理自己的消费进度（这样就算消费者宕机，只需要将消费者的消费进度持久化，也不会miss消息）

RocketMQ通过将一个主题中的队列分布到不同的服务器节点中的方式，提高了一个主题的并行消费性能，所以RocketMQ的TPS能够达到几十万/s，相比之下RabbitMQ的TPS为几万/s，因为RabbitMQ的队列模型让一个主题的所有消息都存放在同一个服务器节点，消息的存储能力受限于单机性能
