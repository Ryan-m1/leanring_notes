# 回溯算法

![image.png](https://raw.githubusercontent.com/syllr/image/main/uPic/20210924034502e4OoqD.png)

**回溯算法通过深度优先遍历实现搜索所有的问题的答案**

* 回溯算法和动态规划解决的问题有这样的特点：解决一个问题有多种办法，每一种办法有多个步骤，如果题目要求得到所有的问题的解，使用回溯算法；
* 与之相对的是：如果题目只是要求得到一个汇总值（计数、最大值、最小值），使用动态规划；

## 算法定义

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

* 找到一个可能存在的正确的答案；
* 在尝试了所有可能的分步方法后宣告该问题没有答案；

### 回溯算法与深度优先遍历密不可分

简单归纳一下：回溯算法也叫 回溯搜索算法，「搜索」的意思是「搜索所有的解」。回溯算法从初始状态出发，采用 深度优先遍历 的方式，得到问题的 所有 的解。因为采用遍历的方式，所以可以得到所有的解。

在一些教程上，回溯算法也叫做 暴力搜索（也称为穷举），但它不像我们写几个 for 循环那么朴素、暴力。回溯算法按照一定的方向进行搜索，这里方向是深度优先遍历的方向。

### 回溯算法的适用范围

回溯搜索问题通常问我们一个问题的所有解决方案。如果解决一个问题有多个解决方案，每一个解决方案有多个步骤，题目要求我们得到所有的解，就可以使用回溯算法。

多个解决方案，每一个解决方案有多个步骤，通常可以建模成一个 树形问题。而树形问题中有着很明显的递归结构，因此 回溯算法递归地建立了局部的可能的解决方案，当发现一个可能的解决方案无法得出正确的结果时，回退到上一步，尝试下一个可能的解决方案 ，这里的 「回退」就是「回溯」的意思。

> 友情提示：深度优先遍历，从直观上看有着很明显的 **回退** 的步骤，当回退发生的时候，所有的变量都要重置为和原来的变量一样，回退才会有意义。

还可以这样理解 树形问题：要解决一个问题有多个步骤，每一个步骤有多种选择，使用回溯算法通过深度优先遍历得到所有的解决方案。

回溯算法有 通用解题方法 的美称，但是它采用遍历的思想，复杂度很高。我们在解决算法问题的时候，需要根据不同的问题场景设计最合适的算法。

![image.png](https://raw.githubusercontent.com/syllr/image/main/uPic/20210924040526Jrlf0r.png)

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    //回溯先确定需要的状态变量
    //最终结果的长度，用来判断是否结束,开启回溯
    int length;
    //path，记录已经选中的路径，方便回溯，因为只在末尾操作（在末尾新增或者删除）在形式上是一个栈
    //但是由于需要拷贝pathStack中的所有数据，所以用List代替
    List<Integer> pathStack = new ArrayList<>();
    //记录当前哪些元素已经使用，哪些未使用
    int[] used;

    public List<List<Integer>> permute(int[] nums) {
        length = nums.length;
        used = new int[length];
        List<List<Integer>> res = new ArrayList<>();
        backTrack(nums, res);
        return res;
    }

    /**
     * 回溯代码
     */
    private void backTrack(int[] nums, List<List<Integer>> res) {
        //递归开始的时候先对递归的终止进行判断
        if (pathStack.size() == length) {
            //因为path变量是一个通用的变量，所以在真正插入结果的时候应该将path变量拷贝一份
            res.add(new ArrayList<>(pathStack));
            return;
        }
        //对nums中的每一个元素都进行遍历
        //并且判断是否被使用过，这样可以避免第一层遍历和第二层遍历获取到同样的元素
        for (int index = 0; index < nums.length; index++) {
            //判断当前元素是否已经被使用
            if (used[index] == 0) {
                //没有被使用，直接加入路径
                pathStack.add(nums[index]);
                //维护used数组
                used[index] = 1;
                //进入下一层递归
                backTrack(nums, res);
                //非常重要，当这一层递归退出的时候，需要把在这一层设置的path和used状态变量恢复到以前
                pathStack.remove(pathStack.size() - 1);
                used[index] = 0;
            }
        }
    }
}
```

![image-20210924094926166](https://raw.githubusercontent.com/syllr/image/main/uPic/20210924094928HJdNQ4.png)

#### 设计状态变量

状态的意思是：**为了得到一个解决方案，程序已经执行到了哪一步，这个概念很重要**，在动态规划问题中也会用到。

我们观察到：在**非叶子结点处**的操作都是寻找剩下的（还未选择的）数字集合的全排列（递归）。因此，已经选出的数就需要记录下来，我们可以使用布尔数组 used 记录已经选择的数（如果不这么做，就需要遍历已经选择的数，时间复杂度会增加）。

在非叶子结点需要确定全排列的某一位数字，我们将它的下标记为 index。递归终止条件是 index = nums.length，即：所有的位置都确定完了，我们就得到了一个全排列。

由于我们需要记录所有的具体的排列，因此我们还需要一个变量，它记录了：为了得到一个排列，已经选出了那些数和 选出这些数的顺序（因为排列和顺序相关），记为 path（这个变量命名有通用性，请大家留意），选出了一个还没有选过的数以后，就需要将它添加到 path 中。

整理一下，全排列问题需要的状态变量有：

* 整型变量 index ：表示当前需要确定的下标位置；
* 布尔数组 used ：记录某个下标的元素是否使用过；
* 列表 path：记录从根结点到任意结点的路径。

列表 path 这个变量很重要，理解它的作用和在深度优先遍历的过程中变化的规律非常关键，我们通过一个动画向大家展示 path 是如何在 深度优先遍历 的过程中。请大家重点理解：深度优先遍历有回退的过程，从深层结点回到浅层结点的过程中，为了得到另一个全排列，path 变量需要将末尾元素移出。

> path 变量是栈
>
> path 变量由于我们只在末尾操作，因此它在数据结构上是一个栈，由于 Java 官方文档推荐我们使用 java.util.ArrayDeque 作为实现。既然是数组实现，底层一定是动态数组，因此我们在初始化的时候，可以传入动态数组的长度，以避免扩容带来的性能消耗。
>

#### 为什么不是广度优先遍历

广度优先遍历也是一种遍历的行为，它也能搜索得到所有的解。但是广度优先遍历这个行为是 像水波纹一样一层一层向外扩张，每一层的状态变量需要保存下来，这种方式需要大量的空间。

相比较于深度优先遍历而言，深度优先遍历在不同阶段，状态变量的差异只有1个操作，不像广度优先遍历那样有跳跃的行为，因此深度优先遍历可以成为强大的搜索算法。

下面我们给出一个等式，这个等式涵盖了回溯算法的内容。可以用于帮助理解回溯算法。

![image.png](https://raw.githubusercontent.com/syllr/image/main/uPic/20210924100512KKZZrP.png)

### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)