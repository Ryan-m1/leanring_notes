# 优先队列

优先队列和普通队列的唯一区别就是优先队列在元素出队的时候做了特殊的规定：按照元素的优先级顺序出队

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210920092309sXF6g9.png)

# 优先队列与堆

优先队列是抽象数据类型（Java 用户可以理解只定义接口，不规定实现），堆是具体的、高效的实现。在一些编程语言的实现中，二者不加区分。

# 优先队列的实现

## 数组实现（线性存储）

* 有序数组：入队时维护有序性。出队的时候，以 O(1)O(1) 的时间复杂度找到优先级最高的元素；
* 无序数组：事实上也可以不维护优先队列的顺序，在出队的时候遍历数组（时间复杂度 O(N)O(N)），选出优先级最高的元素。

我们把两种实现方案的「入队」和「出队」操作的时间复杂度列在下面这张表中，发现两种方案 至少有一个 操作是线性复杂度，即：在最坏情况下，不得不把整个数组的元素都看一遍。

| 优先队列实现 | 入队 | 出队 |
| ------------ | ---- | ---- |
| 有序数组     | O(N) | O(1) |
| 无序数组     | O(1) | O(N) |

有没有更好的实现方案，能够将「入队」和「出队」的时间复杂度平衡起来。事实上，「堆」就是更高效的数据结构。

根据我们对有序数组和无序数组的分析，我们发现：如果不改变线性的数据存储的方式，就不能突破时间复杂度为 O(N)O(N) 的限制，因此我们必须考虑其它的数据的组织方式。

## 树形结构

事实上，确定当前优先级最高的元素并不需要与所有的其它元素进行比较。在体育比赛中，有一种比赛机制叫做淘汰赛，假设有 NN 名选手参赛，决出第 11 名的方式是两两进行一场比赛，输的那一方被淘汰。在这个规则下，只需要进行 N - 1N−1 场比赛就可以确定冠军是谁。

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210920094629eslZ5i.png)

而确定亚军，只需要对那些 所有输给冠军 的选手也按照同样的方式每举行一场比赛，在这些输给冠军的选手里选出那个最优秀的选手，就是亚军。而那些都没有机会和冠军过招的选手，自然就没有必要参与角逐亚军的比赛。

这个例子说明：**在优先队列的应用场景下，使用 树形结构 是更好的选择。**

### 完全二叉树与满二叉树

首先我们介绍 **完全二叉树**。完全二叉树首先是一棵二叉树（每个结点最多有 22 棵子树）。「完全」的意思是：在二叉树的基础上，从上至下、从左至右没有空结点。

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210920094706TuZ20a.png)

如果 **完全二叉树** 的最后一层没有空结点，此时完全二叉树称为 **满二叉树**。将满二叉树每一层结点的个数依次排列开来，是一个 **等比数列**。

### 使用数组表示完全二叉树（重要）

完全二叉树有个重要的性质：它 可以使用数组表示。这是因为按照从上至下、从左至右的顺序给完全二叉树编号，任意结点的父亲结点和子结点的下标是有规律的。这一点决定了，在完全二叉树中，左右子结点、父结点可以根据当前下标数值 互相访问：

* 根据父亲结点的下标，可以访问到它的两个子结点；
* 根据子结点的下标，可以访问到它的唯一的父亲结点。

使用数组存放二叉树的优点是：不用维护左右子结点、父结点的引用关系。这是因为如果我们给二叉树的结点的顺序编号，就不难发现它们的规律。下面的图展示了父亲结点的下标与孩子结点的下标的关系。可以说在优先队列的场景下，利用完全二叉树可以使用数组表示的特性，既可以节约空间也可以节约时间。

#### 从下标 00 开始存储数据

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210920094946pu1gE4.png)

我们还可以从下标 11 开始编号，此时从父亲结点和子结点的下标关系从形式上看会更简单一些，少了偏移量的计算。

**说明：无须记忆这个规律，如果忘记了，可以在纸上画一棵完全二叉树观察得到下标之间关系。**

#### 从下标 11 开始存储数据

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210920095012Pa0ebT.png)

#### 堆有序

我们先介绍「最大堆」。最大堆是完全二叉树，满足任意某个结点的值，总是不大于其父亲结点的值。也就是说：从任意一个局部看，子结点的值一定不会超过父结点的值。这是一种特殊意义下的 有序 的树形结构，称之为 堆有序。

在这种定义下，**树根结点这个元素一定是这棵二叉树中值最大的结点** ，所以「最大堆」也叫做「大顶堆」、「大根堆」。

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210920095050f1mtQu.png)

同理，可以定义「最小堆」、「小顶堆」、「小根堆」。

![image.png](https://gitee.com/syllr/images/raw/master/uPic/202109200951054rMAmY.png)

> 友情提示：堆中的元素在增加、删除的过程中，始终维护了「堆有序」的性质。这一点也是维护「循环不变量」思想的体现。

如果一个数组表示的树形结构符合上述性质，这个数组称为堆（Heap），这个性质称为「堆有序」。我们举的例子总是以数值最大作为优先级最高，此时称为 最大堆。而数值越小，优先级越高的堆，称之为 最小堆。

## 堆的基本操作

sift up 和 sift down

![image.png](https://gitee.com/syllr/images/raw/master/uPic/202109200955040inTMZ.png)

### 如何维护堆有序（特别重要）

维护堆有序需要特别注意两点：

* 完全二叉树中的元素可以使用数组存放（下标有固定规律）；
* 对于数组来说，能 O(1) 操作的元素的位置在数组的末尾，故「添加」、「删除」元素都需要尽可能与数组 末尾 的元素产生关系。

总结下来在对堆进行添加删除的时候需要做到：

* 添加元素的时候直接放在堆的末尾（也就是数组的末尾），从堆的末尾sift up到堆顶
* pop出堆内最大（或最小）元素的时候，用堆的末尾元素（也就是数组的末尾）来替换最大（或最小）元素，从堆顶sift down到叶子结点

具体流程如下

![image-20210920110414490](https://gitee.com/syllr/images/raw/master/uPic/20210920110415FhDZcQ.png)

1. 堆为空，添加节点为4，直接放在堆尾（也就是根节点，因为现在堆为空）

   ![image-20210920110528012](https://gitee.com/syllr/images/raw/master/uPic/20210920110532CtTldy.png)

2. 接下来添加76，把76放在堆末，然后找到76的父亲节点4，首先对比4节点的两个叶子结点看谁大（因为现在4只有一个76节点，所以就直接选中76）选出叶子结点中最大的maxChild，