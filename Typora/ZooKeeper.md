![通过zk进行主从配置](https://gitee.com/syllr/images/raw/master/uPic/20210826162704iYaR8Z.png)

# ZK事务

# 脑裂

* 羊群效应：Zookeeper分布式锁场景中的羊群效应指的是所有的客户端都尝试对一个临时节点去加锁，当一个锁被占有的时候，其他的客户端都会监听这个临时节点。一旦锁被释放，Zookeeper反向通知添加监听的客户端，然后大量的客户端都尝试去对同一个临时节点创建锁，最后也只有一个客户端能获得锁，但是大量的请求造成了很大的网络开销，加重了网络的负载，影响Zookeeper的性能，所有客户端都尝试去创建临时有序节点以获取锁
  序号最小的临时有序节点获得锁
  未获取到锁的客户端给自己的上一个临时有序节点添加监听
  获得锁的客户端进行自己的操作，操作完成之后删除自己的临时有序节点
  当监听到自己的上一个临时有序节点释放了锁，尝试自己去加锁
  操作完成之后释放锁
  之后剩下的客户端重复加锁和解锁的操作
* zk在通知的时候如果一个update没有通知完，不会去通知另一个update的通知
* 可以利用zk的watcher机制来做缓存，客户端读取znode数据的时候默认读取缓存，如果缓存读不到就去zk读数据，当watcher收到这个节点数据变更的通知，客户端就把这个节点数据的缓存置为空
* 在修改znode数据和读取znode数据的时候都通过zk来读取，不要客户端之间交换数据
* session是否过期是由zk服务端集群管理的，而不是zk客户端自己管理自己是否过期。zk服务端就是根据session过期时间来判断是否过期。当zk服务端超过一定的时间没有收到来自zk客户端的心跳，zk服务端就把这个session标记为过期，然后删除这个session创建的所有临时节点，并且李克通知所有监听了这些节点的其他session。在这个时候，zk客户端处于断开连接的状态，一旦它重新连接成功了，他也会收到自己被标记为过期这一事件提醒；在还没有重新连接成功之前，这个zk客户端是不会收到过期的提醒的。
* watch的机制，就算是修改了同样的数据在session重连之后也会接收到通知，但是如果是watch节点是否exist就不行。
* 可以利用zookeeper的zxid（事务id）来实现fence机制，就是kafka的epoch机制，在选主的时候有效防止脑裂的发生。
* zookeeper的节点有版本号机制，如果删除节点然后再新增会重置版本号为0

# 分布式理论

## 四大基础理论

### 拜占庭将军问题

### CAP理论

### ACID理论

### BASE理论

## 八大分布式协议和算法

### paxos算法

### Raft算法

### 一致性hash算法

### Gossip算法

### Quorum NWR算法

### FBFT算法

### POW算法

### ZAB协议

## 四大维度

### 拜占庭容错

### 一致性

### 性能

### 可用性
