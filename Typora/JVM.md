# Java内存区域

不同版本的JAVA内存区域划分不一样

## JDK1.7及以前

![img](https://raw.githubusercontent.com/syllr/image/main/uPic/202110062119516Hq8OU.png)

## JDK1.8及之后

<img src="https://img2018.cnblogs.com/blog/1742867/201910/1742867-20191022115808845-1101254140.jpg" alt="jvm内存结构" style="zoom:67%;" />

## 线程隔离数据区

### 虚拟机栈

虚拟机栈和普通的栈一样是一个先进后出的数据结构，而虚拟机栈所存的节点是**栈帧**，**栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。**

在在活动线程中，只有位于JVM虚拟机栈栈顶的元素才是有效的，即称为**当前栈帧**，与这个栈帧相关连的方法称为**当前方法，**定义这个方法的类叫做**当前类**。

在概念模型上，典型的栈帧结构如下：

![img](https://raw.githubusercontent.com/syllr/image/main/uPic/20211006213012kZJqQG.jpg)

#### 局部变量表

**局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。

* 基本数据类型直接存储在局部变量表中
* 引用数据类型的局部变量，局部变量表里面存储对象的引用

#### 操作数栈

**操作数栈(Operand Stack)**也常称为操作栈，先进后出。在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈和出栈操作，主要是用来解析表达式，保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。（和leetCode中用栈实现解析后缀表达式一个道理）

#### 动态链接

在一个class文件中，一个方法要调用其他方法，会用到**方法调用指令**，方法调用指令会根据方法的符号引用去找到方法的直接引用地址（真实调用地址）然后执行方法调用

先看Class文件里的“符号引用”。

考虑这样一个Java类：

```java
public class X {
  public void foo() {
    bar();
  }

  public void bar() { }
}
```

它编译出来的Class文件的文本表现形式如下：

```java
Classfile /private/tmp/X.class
  Last modified Jun 13, 2015; size 372 bytes
  MD5 checksum 8abb9cbb66266e8bc3f5eeb35c3cc4dd
  Compiled from "X.java"
public class X
  SourceFile: "X.java"
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#16         //  java/lang/Object."<init>":()V
   #2 = Methodref          #3.#17         //  X.bar:()V
   #3 = Class              #18            //  X
   #4 = Class              #19            //  java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               LocalVariableTable
  #10 = Utf8               this
  #11 = Utf8               LX;
  #12 = Utf8               foo
  #13 = Utf8               bar
  #14 = Utf8               SourceFile
  #15 = Utf8               X.java
  #16 = NameAndType        #5:#6          //  "<init>":()V
  #17 = NameAndType        #13:#6         //  bar:()V
  #18 = Utf8               X
  #19 = Utf8               java/lang/Object
{
  public X();
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return        
      LineNumberTable:
        line 1: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   LX;

  public void foo();
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokevirtual #2                  // Method bar:()V
         4: return        
      LineNumberTable:
        line 3: 0
        line 4: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   LX;

  public void bar();
    flags: ACC_PUBLIC
    Code:
      stack=0, locals=1, args_size=1
         0: return        
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       1     0  this   LX;
}
```

可以看到Class文件里有一段叫做“常量池”，里面存储的该Class文件里的大部分常量的内容。

来考察foo()方法里的一条字节码指令：

```java
1: invokevirtual #2  // Method bar:()V
```

从Class文件中的常量池可以看出

```java
#2 = Methodref          #3.#17         //  X.bar:()V
```

```java
#13 = Utf8               bar
```

```java
#17 = NameAndType        #13:#6         //  bar:()V
```

**Class文件在方法区中**，线程在运行的时候无法看到Class文件的常量池

线程中只能看到

```java
invokevirtual #2  // Method bar:()V
```

而方法调用指令需要知道#2所代表的符号引用，所以必须要去方法区存放的Class文件里面的常量池查找，是一个Class文件一个常量池，所以是先找到Class文件，然后再获取到该Class文件的常量池，最后找到符号引用，方法调用指令再进行调用

**为什么要有符号引用呢？**

在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，**这个符号引用一般都能够无歧义地定位到具体目标上**（这个涉及到JVM的方法调用逻辑）

#### 方法返回地址

一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。

### 本地方法栈

和java虚拟机栈的作用类似，不同点在本地方法栈主要是为虚拟机使用到的Native方法提供服务，本地方法栈也会抛出StackOverFlowException和OutOfMemoryException异常。

### 程序计数器

程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器

## 线程共享的数据区

### 堆

对于Java应用程序来说，Java堆(Java Heap)是虚拟机所管理的内存中最大的一块。Java堆是被所 有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。

JVM将所有对象的实例（即用new创建的对象）（对应于对象的引用（引用就是内存地址））的内存都分配在堆上，堆所占内存的大小由-Xmx指令和-Xms指令来调节

### 方法区/元数据

方法区是JVM逻辑上的分区，不同版本的JDK实现不一样，逻辑上方法区内部分为类信息和运行时常量池两个部分

<img src="https://img-blog.csdn.net/20180715132155432?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MTI3NzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:67%;" />



#### 类信息

我们先来看一下被编译后的Class文件

```java
Classfile /private/tmp/X.class
  Last modified Jun 13, 2015; size 372 bytes
  MD5 checksum 8abb9cbb66266e8bc3f5eeb35c3cc4dd
  Compiled from "X.java"
public class X
  SourceFile: "X.java"
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#16         //  java/lang/Object."<init>":()V
   #2 = Methodref          #3.#17         //  X.bar:()V
   #3 = Class              #18            //  X
   #4 = Class              #19            //  java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               LocalVariableTable
  #10 = Utf8               this
  #11 = Utf8               LX;
  #12 = Utf8               foo
  #13 = Utf8               bar
  #14 = Utf8               SourceFile
  #15 = Utf8               X.java
  #16 = NameAndType        #5:#6          //  "<init>":()V
  #17 = NameAndType        #13:#6         //  bar:()V
  #18 = Utf8               X
  #19 = Utf8               java/lang/Object
{
  public X();
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return        
      LineNumberTable:
        line 1: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   LX;

  public void foo();
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokevirtual #2                  // Method bar:()V
         4: return        
      LineNumberTable:
        line 3: 0
        line 4: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   LX;

  public void bar();
    flags: ACC_PUBLIC
    Code:
      stack=0, locals=1, args_size=1
         0: return        
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       1     0  this   LX;
}
```

JVM会把这个Class文件加载到方法区中，主要这么几个部分

1. 类型信息
   1. 类型的全限定名
   2. 超类的全限定名
   3. 直接超接口的全限定名
   4. 类型标志（该类是类类型还是接口类型）
   5. 类的访问描述符（public、private、default、abstract、final、static）
2. 类型的常量池：存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存中所有类型使用到的类型、字段、方法的字符引用，所以它也是动态连接的主要对象（在动态链接中起到核心作用）。
3. 字段信息（该类声明的所有字段）
   1. 字段修饰符（public、protect、private、default）
   2. 字段的类型
   3. 字段名称
4. 方法信息，方法信息中包含类的所有方法，每个方法包含以下信息：
   1. 方法修饰符
   2. 方法返回类型
   3. 方法名
   4. 方法参数个数、类型、顺序等
   5. 方法字节码
   6. 操作数栈和该方法在栈帧中的局部变量区大小
   7. 异常表
5. 类变量（静态变量）：指该类所有对象共享的变量，即使没有任何实例对象时，也可以访问的类变量。它们与类进行绑定。
6. 指向类加载器的引用：每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。
7. 指向Class实例的引用：类加载的过程中，虚拟机会创建该类型的Class实例，方法区中必须保存对该对象的引用。通过Class.forName(String className)来查找获得该实例的引用，然后创建该类的对象。
8. 方法表：为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素是实例可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的，类似C++虚函数表vtbl。

#### 运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分.Class文件中除了有类的版本/字段/方法/接口等描述信息外,还有一项信息是**常量池(Constant Pool Table)**，用于存放编译期生成的各种字面量和符号引用,这部分内容将类在加载后进入方法区的**运行时常量池**中存放，JVM会把加载的Class文件中的常量池存放到运行时常量池中

运行时常量池相对于Class文件常量池的另外一个重要特征就是具备动态性，除了Class文件常量数据，JVM运行期间会动态向运行时常量池中写入数据，比如**字面量(interned strings)**，这部分字面量数据被称为字符串常量池。

#### 字符串常量池

字符串常量池是因为Java为String开辟的一块内存缓冲区，为了提高性能同时减少内存开销。在JVM中，字符串常量池由一个hash表实现。默认容量为1009。当字符串常量池中的存储比较多的字符串时，会导致hash冲突，从而每个节点形成长长的链表，导致性能下降。所以在使用字符串常量池时，一定要控制容量。

* JDK1.7之前及以前字符串常量池中存放的是字符串常量
* JDK1.7之后字符串常量池中存放的是指定字符串的引用

### 方法区的实现

#### 永久代和元空间

在JDK1.8之前是用永久代实现方法区，在JDK1.8及之后使用元空间实现方法区

在JDK1.7之前，方法区中的数据（类信息和运行时常量）都是放在永久代中的，虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类信息直接保存在本地内存区域（堆外内存），称之为元空间。

#### 永久代移除的原因

1. 永久代的**GC**是和老年代(old generation)捆绑在一起的，无论谁满了，都会触发永久代和老年代的垃圾收集。
2. 字符串常量池存在永久代中，容易触发永久代和老年代的GC和内存溢出
3. **类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。**
4. 永久代会使GC回收策略更复杂

#### 如何移除永久代

* 符号引用(Symbols)和Class信息转移到了堆外内存（native heap，就是C heap）
* 类的静态变量(class statics)转移到了java heap
* 字面量（包括字符串常量池）(interned strings)转移到了java heap

### String.intern()

String.intern()是一个Native方法，底层调用C++的 `StringTable::intern` 方法，源码注释：当调用 intern 方法时，如果常量池中已经该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回字符串的引用。

因为在JDK1.7的时候字符串常量池被移到了堆中，并且1.7之前字符串常量池存的是字符串常量，1.7开始存的是字符串的引用。

基于JDK1.8我们来分析下面的代码输出

```java
/**
 * @author yutao create on 2020/12/9 7:19 下午
 */
public class Test {
    public static void main(String[] args) {
        String test2 = new String("test2");
        String test2Repeat = new String("test2");
        System.out.println(test2 == test2Repeat);//false，test2和test2Repeat都是在堆中新建的对象

        String test3 = "test3";
        String test3Repeat = "test3";
        System.out.println(test3 == test3Repeat);//true，test3和test3Repeat都是字符串字面量，在编译的时候会被放入字符串常量池中

        String test = new String("test");
        System.out.println(test.intern() == "test");//true，因为test.intern()是从字符串常量池中寻找test字符串
        System.out.println(test == "test");//false，test是堆中的对象，"test"是在字符串常量池中存储的"test"（虽然这个引用的地址也是在堆中）的引用

    }
}
```

### 总结

在JDK1.7及之前所谓的方法区其实也是放在堆里面的，和堆一样被垃圾收集器管理，而1.8之后把符号引用和Class信息等静态的不变量转移到了native heap（就是C heap）中，把静态变量和字面量放在了堆中，其就是就以前JDK的团队搞了个永久代出来，后来发现永久代不好用，有点过度设计了，然后就把永久代删除了。

# 垃圾收集

## 判断对象是否被存活

判断对象是否存活主要有两种方法，一是引用计数法，二是可达性分析

## 引用计数法

很多教科书判断对象是否存活的算法是这样的:在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一;当引用失效时，计数器值就减一;任何时刻计数器为零的对象就是不可能再被使用的。

客观地说，引用计数算法(Reference Counting)虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法，**但是引用计数法无法解决循环引用的问题**。所以主流的Java虚拟机里面都没有选用引用计数算法来管理内存。

## 可达性分析算法

主流JVM都是用可达性分析算法来判定对象是否存活

这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

![image-20211007200811956](https://raw.githubusercontent.com/syllr/image/main/uPic/202110072008145o7Emh.png)

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种:

* **Class对象** - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，
* **Thread** - 线程对象
* 虚拟机栈中的所有引用对象
* Native栈里面的所有引用对象
* 所有跨代引用对象
* 和已知 GCRoots 对象同属一个CardTable 的其他对象

总结下来包括，Class对象，虚拟机栈所有引用对象，Native栈所有引用对象，所有垮代引用对象，和已知 GCRoots 对象同属一个CardTable 的其他对象

## 引用的分类

引用分为强引用(Strongly Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。

* 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。
* 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常，软引用可以用来实现本地缓存
* 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象，主要是用来和强引用搭配起来用，当一个对象又被强引用，又被软引用的时候，如果强引用断开则这个对象可以被GC，ThreadLocal中的threadLocalMap的entry的key就是弱引用
* 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知，虚引用更像是一个钩子

## finalize()

当对象被判定为不可达时，如果这个对象有finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法，但是并不一定保证finalize()一定会执行完成，并不等同于C++的析构函数，finalize()具有极大的不确定性，建议不要使用

## 垃圾收集算法

### 分代收集理论

* 弱分代假说(Weak Generational Hypothesis):绝大多数对象的存活时间都很短。 
* 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则:收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。

> 在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“M inor GC”，“Major GC”，“Full GC”这样的回收类型的划分;也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”，“标记-清除算法”，“标记-整理算法”等针对性的垃圾收集算法。

一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域

* 在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放

* 对象不是孤立的，**对象之间会存在跨代引用**，比如新生代的对象持有老年代对象的引用，或者老年代对象持有新生代对象引用

> 假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样

* 跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说仅占极少数。

只需在新生代上建立一个全局的数据结构(该结构被称 为“记忆集”，Remembered Set)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数 据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

> 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，实现的方式有很多，JVM最常用的就是用卡表来实现记忆集，卡表将非收集区域分为很多块，记录每一块中是否有指向收集区域的指针
>
> 使用写屏障来实现卡表记录的更新，写屏障相当于字节码层面的AOP，有前写屏障（在变量写入之前触发）和后写屏障（在变量写入之后触发）

### 标记清除法

标记清除法是先找到内存里的存活对象并对其进行标记，然后统一把未标记的对象统一的清理，过程大致如下

<img src="https://raw.githubusercontent.com/syllr/image/main/uPic/20211008004756wHLcRH.jpg" alt="img" style="zoom:67%;" />

* 优势：简单直接，速度也非常块，特别适合可回收对象不多的场景。
* 劣势
  * **会造成不连续的内存空间：**就像上图清除后的内存区域一样，清除后内存会有很多不连续的空间，这也就是我们常说的空间碎片，这样的空间碎片太多不仅不利于我们下次分配，而且当有大对象创建的时候，我们明明有可以容纳的总空间，但是空间都不是连续的造成对象无法分配，从而不得不提前触发GC。
  * **性能不稳定：**内存中需要回收的对象，当内存中大量对象都是需要回收的时候，通常这些对象可能比较分散，所以清除的过程会比较耗时，这个时候清理的速度就会比较慢了。

### 标记复制法

标记清除法最大问题是会造成空间碎片，并且只适合需要回收的对象比较少的场景，那么针对这个问题就衍生了标记复制法

标记复制法专门针对这两个问题进行了解决。标记清除法的关注点在可回收的对象身上，而标记复制法的关注点则放在了存活的对象身上，通过把存活的对象放复制一个固定的区域，然后对其他区域的对象进行统一清理。

首先它把内存划分出三块区域，一块用于存放新创建的对象叫Eden区，另外两块则用于存放存活的对象分别叫 S1区和S2区。回收的时候会有两种情况，

* 一种是把Eden和S1区的存活对象复制到S2区
* 第二种是把Eden和S2区的存活对象复制到S1区 

也就是说S1区和S2这两块区域同时只会有一块使用，通过这种方式保证始终会有一块空白的区域用于下次GC时存放存活的对象，而且原来的区域不需要考虑保留存活的对象，所以可以直接一次性清除所有对象,这要既简单直接同时也保证了清除的内存区域的内存连续性。

<img src="https://raw.githubusercontent.com/syllr/image/main/uPic/20211008010024WsFuFT.jpg" alt="img" style="zoom:67%;" />

#### 为什么标记复制法需要两个survivor区

* 如果分为eden和survivor区，每次eden满了触发一次Minor GC，存活下来的复制到到servivor，那发生第二次Minor GC的时候，eden和servivor区都会被清除，然后复制到servivor区的空闲部分，这个时候servivor区就有碎片了
* 如果分为eden和survivor区，每次eden满了触发一次Minor GC，存活下来的移动到servivor，把原来的eden作为survivor，把以前的servivor作为eden，这样行不行，这样是可行的，不会产生碎片，但是这样必须要eden和survivor的容量一样大
* 如果分eden和s1，s2，eden的容量比s1，和s2大，虽然每次Minor GC，s1，s2只有一块区域使用，但是因为eden区域远大于s1和s2，JVM默认是eden:s1:s2为8:1:1，这样只有少部分内存被空着，也不会有内存碎片

#### 评价

* 优势：标记复制法解决了标记清除法的空间碎片问题，并且采用移动存活对象的方式，每次清除针对的都是一整块内存，所以清除可回收对象的效率也比较高，但因为要移动对象所以这里会耗费一部分时间，所以标记复制法还效率还是会低于标记清除法。
* 不足
  * **会浪费一部分空间：**总是会有一块空闲的survivor区域是利用不到的，这也造成了资源的浪费
  * **存活对象多会非常耗时：**因为复制移动对象的过程是比较耗时的，这个适合不仅需要移动对象本身还需要修改使用了这些对象的引用地址，所以当存活对象多的场景会非常耗时，这也提示我们标记复制法比较适合存活对象较少的场景
  * **需要担保机制：**因为复制区总会有一块空间的浪费，而为了减少浪费空间太多，所以我们会把复制区的空间分配控制在很小的区间，但是空间太小又会产生一个问题，就是在存活的对象比较多的时候，这时复制区的空间可能不够容纳这些对象，这时就需要借一些空间（就是JVM的老年代）来保证容纳这些对象，这种从其他地方借内存的方式我们称它为担保机制

标记复制法是每次把新生代存活的对象**复制**到servivor区，等完全复制完了在对原来的对象进行清理，这样做完全不会影响线程对现有对象的操作，最大的缺点是会占用多余空间以及需要别的空间作为担保机制

### 标记整理法

标记复制法算是完美的补齐了标记清除法的短板，即解决了空间碎片的问题，又适合使用在大部分对象都是可回收的场景。 但是问题是标记复制法并不适用于存活对象多的场景，如果使用标记清除法来处理，那么空间碎片又是一个无法忍受的问题。有了具体的场景和问题，所以就有了标记整理法，它是专门针对于存活对象多的情况下进行垃圾收集当然同时需要要避免产生空间碎片。

标记整理法分为标记和整理两个阶段，标记阶段会先把存活的对象和可回收的对象标记出来；标记完之后就是进行整理了，这个阶段会把存活的对象往内存的一端移动，移动完对象后再清除存活对象边界之外的对象。

![495229_201212191517480603](https://raw.githubusercontent.com/syllr/image/main/uPic/20211008015023AnVWPf.png)

* 优点：标记整理法最大的特点就是解决了标记清除法的空间碎片问题，同时也不至于像标记复制法需要空闲的内存空间，所以它非常适合存活对象多的场景。
* 缺点：标记整理法是三种垃圾回收算法中性能最低的一种，因为标记整理法在移动对象的时候不仅需要移动对象，还要额外的维护对象的引用的地址，这个过程可能要对内存经过几次的扫描定位才能完成，做的事情越多那么必然消耗的时间也越多。

标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的

### 分代收集算法

现在的JVM的垃圾收集器都是采用分代收集算法，一般是把Java堆分成新生代和老年代（JDK1.8以前还有永久代），这样就可以根据各个年代的特点采用最适合的收集算法

* 对于新生代，对象的存活时间非常短，每次GC之后存活下来的对象非常少，可以选择标记复制算法，因为对象的数量少，所以复制的过程也少，而且可以选择老年代作为分配担保，如果对象存活时间非常长，或者对象大小超过空闲内存大小，把对象移动or新建到老年代
* 对于老年代，对象的存活时间非常长，而且没有额外的空间作为分配担保，所以不能使用标记复制法，就可以使用标记清除或者标记整理算法

## JavaGC实现

### 准确式GC和OopMap

GC Roots对象中只有一部分是Reference类型的，如果能准确知道对象中哪个位置是Reference类型，就可以实现准确式GC，不然只有从头到尾扫描整个对象，来判断哪些是Reference类型，HotSpot是利用OopMap来实现准确式GC的

OopMap是把GC Roots对象中代表的引用的位置全部记录下来，这样到真正gc的时候就可以直接读取，而不用再一点一点的扫描了，理论上来说只要引用关系发生了变化就要更新OopMap，如果每次引用关系发生了变化都要去修改OopMap的话，这又是一件成本很高的事情。所以这里就引入了安全点的概念。

### 安全点

并不需要一发生改变就去更新这个映射表。只要这个更新在GC发生之前就可以了。所以OopMap只需要在预先选定的一些位置上记录变化的OopMap就行了。这些特定的点就是SafePoint（安全点）。由此也可以知道，程序并不是在所有的位置上都可以进行GC的，只有在达到这样的安全点才能暂停下来进行GC。

Safepoint的选定即不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的–因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如

* 方法调用
* 循环跳转
* 异常跳转

对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所以线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。

怎么判断是否停下当前线程：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

### 安全区域

安全点是要线程主动去轮训中断标志，但是当线程阻塞的时候，线程无法“走“到安全点去，所以就引入了安全区域的概念，当线程被阻塞了，也就不会对内存数据进行修改，所以被阻塞的线程自然就是安全的，

* 只需要线程在被阻塞前，宣布自己进入了安全区域，这样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了
* 当线程要被唤醒时，需要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就宣布自己离开了Safe Region，否则它就必须继续等待直到收到可以安全离开Safe Region的信号为止。

### Stop The World

GC一定需要所有线程同时进入 SafePoint，并停留在那里，等待GC线程处理完内存（并不是整个GC过程，可能只是生成快照），再让所有线程继续执。像这种**所有线程进入 SafePoint **等待的情况，就是 Stop the world

GC的时间≈根节点枚举时间+复制对象的时间

* 根节点枚举：可达性分析算法都有标记的过程，就是根节点枚举，迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，需要所有用户线程在到达安全点的时候停止，将当前根节点的引用关系生成一个快照，因此毫无疑问根节点枚举会Stop The World。

* 复制对象：标记-复制，标记-整理算法都有复制对象的过程，在这个过程中，为了保证数据的一致性，也是要Stop The World
  * 对于标记-清除算法，只需要对象标记死亡就可以了，不需要涉及到对象的复制，所以标记-清楚法只会在标记阶段造成Stop The World
  * 对于标记-复制算法，需要将存活的对象复制到servivor区，因为本身新生代存活的对象就很少，所以在对象复制阶段Stop The World的时间较短
  * 对于标记-整理算法，本身老年代的存活对象非常多，在对象复制阶段需要复制的对象非常多，Stop The World的时间最长

### 根节点分析的一致性的快照

可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析， 这意味着必须全程冻结用户线程的运行（STW）

在枚举根节点的时候需要STW，但是在从根节点向下遍历的时候可以不需要STW

> 通过三色标记法可以得知，如果在从根节点向下遍历的时候，节点之间的引用关系改变了会影响可达性分析的结果，三色标记法把会影响结果条件分为两种，如果在向下遍历的时候一个操作，同时满足这两个条件才会影响结果，JVM提供了两种机制来解决这个问题，使得在向下遍历的时候不会STW

* 增量更新：在向下遍历的时候，如果有新插入的引用关系（不一定所有的引用都会记录，具体可以去看三色标记法的逻辑），JVM会记录下来
* 原始快照：在向下遍历的时候，如果有引用关系被删除（不一定所有的引用删除都会被记录，具体可以去看三色标记法的逻辑），JVM会记录下来

当根节点向下枚举完成之后，JVM会将增量更新，原始快照中记录的节点当作根节点重新扫描一次，直到最后没有增量更新和原始快照的记录。

## 垃圾收集器

### 经典的分区策略

大多数经典的垃圾收集器都把JVM堆进行分区，大部分会把堆分为新生代和老年代（有的收集器不会这样分区）

* 新生代
  * eden
  * s1
  * s2
* 老年代

新生代对比老年代的比例为1:2，新生代中eden和s1，s2的比例为8:1:1

### GC的分类

针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：

- Partial GC：并不收集整个GC堆的模式

- - Young GC：只收集young gen的GC
  - Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式
  - Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式

- Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。

按照触发条件来看，其实GC只有两种

* Young GC：当young gen中的eden区分配满的时候触发。注意Young GC中有部分存活对象会晋升到old gen，所以Young GC后old gen的占用量通常会有所升高。

* Full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括Young gen，所以不需要事先触发一次单独的Young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次Full GC；或者System.gc()、heap dump带GC，默认也是触发Full GC。

## 垃圾收集器的分类

垃圾收集器的并行，并发

* 垃圾收集器的并行指的是多个垃圾收集线程进行GC，但是用户线程还是要停止
* 垃圾收集器的并发指的是多个垃圾收集线程进行GC，但是用户线程不用停止

<img src="https://raw.githubusercontent.com/syllr/image/main/uPic/20211008140328UTNjxO.png" alt="image-20211008140319868" style="zoom:50%;" />

Hot Spot虚拟机为我们提供了很多垃圾收集器，因为JVM堆是分为新生代和老年代的，所以需要为新生代和老年代分别选出一个垃圾收集器

适用于新生代的收集器有：Serial，ParNew（Serial的多线程版本），Parallel Scavenge（在ParNew的基础上更注重吞吐量）

适用于老年代的收集器有：CMS，Serial Old（Serial的老年代版本）， Parall Old（Parallel Scavenge的老年代版本）

全代收集器：G1，G1适用于新生代和老年代

* Serial：单线程的收集器，单线程的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强 调在它进行垃圾收集时，**必须暂停用户线程，直到它收集结束**，作用于新生代，使用的收集算法是标记-复制算法

  ![image-20211008141124147](https://raw.githubusercontent.com/syllr/image/main/uPic/20211008141127UUPNFa.png)

* Serial Old：Serial的老年代版本，不过因为老年代中对象存活时间长的特性，使用的收集算法是标记-整理算法

* ParNew：Serial的多线程版本，多线程的意思是它会使用多个线程来进行GC，但是它在垃圾收集的时候，和Serial一样必须暂停用户线程的，直到它收集结束，ParNew只能作用于新生代，使用的算法是标记-复制算法

* Parallel Scavenge：和ParNew基本一样，也是多线程GC，但是要暂停用户线程，不一样的是Parallel Scavenge更注重的是吞吐量，而不是底停顿，提供动态调节策略，动态调节新生代中eden，s1， s2的比例，还有对象晋升老年代的GC次数等参数，实现吞吐量最大化，只能用于新生代，使用的收集算法是标记-复制算法

* Parallel Old：Parallel Scavenge的老年代版本，使用的收集算法是标记-整理算法

* CMS：全称Concurrent Low Pause Collector，从名字可以看出最大的两个特点并发低暂停，整体分为4个部分，使用的算法是标记-清楚算法

  * 初始标记(CMS initial mark) STW
  * 并发标记(CMS concurrent mark) 
  * 重新标记(CM S remark) STW
  * 并发清除(CM S concurrent sweep)

  在四个过程中初始标记和重新标记都是会STW的，需要暂停用户线程，其他两个操作均不会影响用户线程，初始标记就是根节点枚举（这个过程需要STW），这时会生成一个引用关系的一致性快照，并发标记会基于这个一致性快照向下遍历，进行可达性分析，所以不需要STW，但是在并发标记期间可能会应用程序线程对对象中的引用进行更新产生两种情况

  1. 本来可达的对象，变得不可达了
  2. 本来不可达的内存，变得可达了

  第一种会变成所谓的浮动垃圾，下一次GC再处理就好了，但是第二种情况是不可容忍的，想象这种情况：在并发标记期间new了一个对象，这就是所谓的不可达对象变成可达了，如果根据并发标记的结果，这个新new的对象会被清楚，这是不可容忍的错误，所以要引入重新标记，在重新标记期间必须要STW，将并发标记期间新增的引用关系作为根节点再向下遍历一次

  > 在并发标记期间所新增的引用关系，JVM会村起来，这种机制叫做，增量更新

  CMS使用的是标记-整理法，不可避免的会产生碎片，如果老年代碎片过多，CMS会Serial Old做一次GC进行碎片整理，这次GC会暂停用户线程非常多的时间，也被有的人称为Full GC（本人并不喜欢这种说法，其实本质山都是老年代的GC，说Full GC只是为了区分，不过表达的不清不楚，让人困惑）。

  在G1没有出来前，一般JDK1.8的服务器采用的GC策略都是ParNew+CMS，因为ParNew和CMS都注重于低停顿。

* G1：**G1不再坚持固定大小以及固定数量的分代区域划分**，而是**把连续的Java堆空间划分为多个大小相等的独立区域（Region），每个Region都可以成为 Eden空间、Survivor空间、老年代空间。**

  ![20210513171250265](https://raw.githubusercontent.com/syllr/image/main/uPic/20211008170347OTifpD.png)

  Region还有一类特殊的 **Humongous 区域**，**专门用来存储大对象**。G1认为**只要大小超过了一个Region容量一半的对象即可判定为大对象**。**如果是那些超过了整个Region容量的超大对象，将会放在连续 N 个 Humongous Region区域。**

  和分代方式一样，G1使用记忆集解决 Region之间存在跨区引用对象问题，**每个Region都有一个对应的记忆集，记录其他Region是否有指向该Region的引用**，**当进行垃圾收集时，在GC Roots枚举范围加上别的只有指向该Region的引用的Region；就可以保证不进行全局扫描了**

  > 因为G1将Java堆划分为一个个Region的缘故，而Region数量相比于传统分代数量明显多得多，所以G1相比于传统的垃圾回收器来说，**需要消耗相当于Java堆容量 10%~ 20%的额外空间来维持收集器的工作。**

  G1的工作流程

  - **初始标记(Initial Marking)**：这阶段**仅仅只是标记GC Roots能直接关联到的对象并修改TAMS(Next Top at Mark Start)的值**，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段**需要停顿线程，但是耗时很短**。而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

  - **并发标记(Concurrent Marking)**：**从GC Roots开始对堆的对象进行可达性分析，递归扫描整个堆里的对象图，找出存活的对象**，这阶段耗时较长，但是可以与用户程序并发执行。当对象图扫描完成以后，还要**重新处理原始快照记录下的在并发时有引用变动的对象。**

  - **最终标记(Final Marking)**：对用户线程做另一个短暂的暂停，**用于处理并发阶段结束后仍遗留下来的最后那少量的原始快照记录。**

  - **筛选回收(Live Data Counting and Evacuation)**：**负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序**，根据用户所期望的停顿时间来制定回收计划。**可以自由选择多个Region来构成会收集，然后把回收的那一部分Region中的存活对象复制到空的Region中，在对那些Region进行清空。**（标记-复制）

    > **除了并发标记外，其余过程都要 STW**

  对比CMS和G1

  * CMS是标记-整理算法，G1是标记-复制算法，因为CMS是只用于老年代的收集器，老年代都是存活比较久的对象，所以如果用标记-复制算法，最后复制的时候会造成很长的STW，但是G1将整个堆分成非常多的Region，可以通过统计判断那些Region死亡的对象多，实际上是另一种形式的新生代，死亡对象多的Region使用标记-复制算法回收起来很快，这也就是为什么CMS只能回收老年代，要搭配ParNew回收新生代了
  * CMS和G1都是将标记的过程做了拆分，拆成了三个部分，第一部分是根节点枚举，这一点两者都一样，或者说任何收集器都一样，都会有STW，在并发标记节点CMS，G1都是从根节点向下遍历，但是CMS会在这个过程中记录增量更新，G1记录的是原始快照（三色标记法），在最终标记/重新标记的阶段，CMS会重新处理增量更新数据，G1处理的是原始快照数据
  * 无论是CMS还是G1解决不了在并发标记阶段原来可达对象变成不可达的情况（浮动数据），不过不影响，可以留到下次GC
  * CMS因为使用的是标记-整理所以会有碎片产生，当碎片多到一定程度会调用Serial Old进行碎片整理，G1采用标记复制不会有碎片产生，但是标记复制方法本身就需要一部分内存空闲，再加上G1把堆内存分成了很多Region（一个Region大小从1M-32M，根据配置来的），每一个Region都需要一个记忆集，记录跨区引用，所以内存消耗还会更多，所以G1会比CMS需要的内存更多

  综上所述，因为现在服务器内存的增加，原来的分代策略需要一次GC扫描收集大量对象，随着内存的增大GC的时间也会增加，CMS已经不是大内存服务器的最优解，G1可以看作是对CMS进行的一次空间换时间的优化。

# 类加载

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最 终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。

与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成 的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销， 但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动 态加载和动态连接这个特点实现的

## 延迟加载

JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。

* 使用new关键字实例化对象的时候
* 读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候。
* 调用一个类型的静态方法的时候。
* 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。
* 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。
* 当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

## ClassLoader分类

JVM 中内置了三个重要的 ClassLoader，分别是 BootstrapClassLoader、ExtensionClassLoader 和 AppClassLoader。

* BootstrapClassLoader：`c++`编写，加载`java`核心库 `java.*`,构造`ExtClassLoader`和`AppClassLoader`。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作

* ExtensionClassLoader：负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，有很多 jar 包。
* AppClassLoader：才是直接面向我们用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。

* URLClassLoader：JDK内置了一个 URLClassLoader，用户只需要传递规范的网络路径给构造器，就可以使用 URLClassLoader 来加载远程类库了。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。

AppClassLoader 可以由 ClassLoader 类提供的静态方法 getSystemClassLoader() 得到，它就是我们所说的「系统类加载器」，我们用户平时编写的类代码通常都是由它加载的。当我们的 main 方法执行的时候，这第一个用户类的加载器就是 AppClassLoader。

## ClassLoader 传递性

程序在运行过程中，遇到了一个未知的类，它会选择哪个 ClassLoader 来加载它呢？虚拟机的策略是使用调用者 Class 对象的 ClassLoader 来加载当前未知的类。何为调用者 Class 对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者 Class 对象。前面我们提到每个 Class 对象里面都有一个 classLoader 属性记录了当前的类是由谁来加载的。

因为 ClassLoader 的传递性，所有延迟加载的类都会由初始调用 main 方法的这个 ClassLoader 全全负责，它就是 AppClassLoader。

## 双亲委派

当一个ClassLoader要加载类的时候不管自己能不能加载该对象，都会先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类

<img src="https://raw.githubusercontent.com/syllr/image/main/uPic/202110090150356Tr5MP.jpg" alt="img" style="zoom: 67%;" />

1. 防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
2. 保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.class`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。

## 自定义加载器

ClassLoader 里面有三个重要的方法 loadClass()、findClass() 和 defineClass()。

loadClass() 方法是加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类。ClassLoader 的 findClass() 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象。

loadClass，findClass，defineClass，findLoadedClass

* loadClass()：就是主要进行类加载的方法，默认的双亲委派机制就是在这个方法中（要破坏双亲委派就重写这个方法）

* findClass()：根据名称或位置加载.class字节码（ClassLoader中默认实现是抛出异常，子类必须要重写这个方法，ExtClassLoader和AppClassLoader都是继承的URLClassLoader），想要自己加载字节码就重写这个方法
* definClass()：把字节码转化为Class，底层是一个native 方法
* findLoadedClasss：如果已经加载过的Class就返回，没有返回null

### Class.forName() 和 loadClass() 加载类的区别

 loadClass() 方法加载类不会对其进行初始化，而通过Class.forName() 方法加载类会对其进行初始化（会执行类里面的静态代码块）。

## 动态代理

### 静态代理

静态代理需要修改代码，比如现在有一个计算器接口类Cal，里面有一个add()方法，现在有一个计算器的实例concreteCal，使用静态代理的一般模式为，新增一个代理类calProxy，实现Cal接口，同时在内部持有一个concreteCal的引用

```java
/**
 * @author yutao create on 2021/10/9 10:33 上午
 */
public class ProxyCal implements Cal {
    //持有要代理的类
    private ConcreteCal concreteCal = new ConcreteCal();

    @Override
    public int add(int x, int y) {
        System.out.println("代理操作");
        return concreteCal.add(x, y);
    }
}
```

### 动态代理

动态代理不需要我们修改源代码重新编译，一般使用两种方式来进行代理

* 利用Java的反射(Proxy类)，JDK动态代理

  > JDK是基于反射机制，生成一个实现代理接口的匿名类,然后重写方法,实现方法的增强.它生成类的速度很快，但是运行时因为是基于反射，调用后续的类操作会很慢.
  >
  > 而且他是只能针对接口编程的，这个更多的是设计上的考量

* 动态修改字节码，CGlib动态代理

  > CGLIB是基于继承机制,继承被代理类,所以方法不要声明为final,然后重写父类方法达到增强了类的作用. 它底层是基于asm第三方框架,是对代理对象类的class文件加载进来,通过修改其字节码生成子类来处理. 生成类的速度慢,但是后续执行类的操作时候很快.
  >
  >  可以针对类和接口

# JAVA对象（Object）

## 初始化对象

* 当新建一个对象的时候，首先会检查这个对象的类是否已经加载过，如果没有就先执行类的加载，类加载完成之后虚拟机将为新生对象分配内存，对象所需的内存大小可以通过他的类信息算出来，而JVM分配内存的方法和GC的算法有关

  >如果内存是连续的（已使用的内存是连续的），假设有一个指针代表现在已经分配的内存，则直接把这个指针后移就可以分配新的对象，这种分配方式称为“指针碰撞”(Bump The Pointer)，如果内存不是连续的（已使用的内存和没有使用的内存是交叉的），则需要维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例并更新列表上的记录，这种分配方式称 为“空闲列表”(Free List)

  * 当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效
  * 而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存

* 不论是修改指针地址还是修改空闲列表，这两种分配内存的方式在多线程下都是不安全的，虚拟机采用了两种方式来保证分配内存的线程安全性

  * 采用CAS配上失败 重试的方式保证更新操作的原子性

  * 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。

    > TLAB上分配的对象并不是线程隔离的，只是这部分内存在执行**分配内存**这个行为的时候只能被一个线程分配内存

* 内存分配完成之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行

* 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用Object ::hashCode()方法时才计算)、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。

* 最后执行该对象的构造函数，完成对象的初始化

## 对象的内存布局

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)

### 对象头

jvm对象头信息是与对象自身定义的数据无关的额外存储的信息，由于它存在于对象中，jvm规范中安装对象类型，分两种类型：

- 普通对象包含：Mark Word、元数据指针（Klass Pointer）
- 数组对象包含：Mark Word、元数据指针（Klass Pointer）、Array Length

![img](https://raw.githubusercontent.com/syllr/image/main/uPic/20211007170629MalTnN.jpg)

1. Mark Word：存储对象的锁信息，hashCode以及GC次数，具体可以查看《高并发-互斥锁》章节，有详细描述
2. 元数据指针：指向该对象对应的Class数据的指针

# Java方法调用

所谓的绑定是指在代码运行期间，将方法或者变量的符号引用替换为直接引用（就是地址）的过程

绑定分为静态绑定和动态绑定

Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

* 像静态方法，被final修饰的方法，对象实例的private方法，Interface的default方法都可以在解析的时候直接被确定，因为这些方法的地址在运行期间是确定的，这种方法叫非虚方法
* Interface中的public方法，普通对象的public方法（可以被子类重写的方法），这些方法具有多肽性，在调用的时候可能会有多个地址，这种方法被称为虚方法；

所以可以重新做一下总结，调用非虚方法的是静态绑定，调用虚方法的是动态绑定

那么怎么调用非虚方法和虚方法呢，首先从字节码中对方法的调用说起。Java的bytecode中方法的调用实现分为四种指令：

* invokevirtual为最常见的情况，包含virtual dispatch机制；

* invokerspecial是作为对private和构造方法的调用，绕过了virtual dispatch;
* invokeinterface的实现跟invokevirtual类似；
* invokestatic是对静态方法的调用；

invokerspecial，invokestatic，都是静态绑定，只需要去Class文件中的常量池查找对应的方法，然后在通过对象引用调用就行了

invokevirtual，invokeinterface是动态绑定，调用的是虚函数，比如调用一个接口Car的drive方法，可能这个接口有多个实现，在运行的过程中不知道是BMWCar，还是BYDCar，所以需要在运行的时候先判断这个对象实例的具体类型，然后通过这个具体类型去找到对象中的方法地址

从对象中找到方法地址的一个方法就是从头到尾遍历这个对象的内存，分析内存，然后找到对应实例方法的地址，这个过程比较耗费时间，为了加速这一过程，JVM会在每一个对象内部存一个方法表，里面存储着这个对象实例的方法和地址（包括从父类继承来的），这样就可以快速的找到虚方法对应的地址，本质上是空间换时间的操作。