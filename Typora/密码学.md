密码学最基础的分支有三个

* 单向散列：可以对消息进行完整性验证
* 对称密码：用来加密解密
* 非对称密码：解决授权和认证的问题

密码学要解决的问题

* 身份识别，身份认证和授权
* 信息的机密性，完整性，可用性

# 安全强度

N位的安全强度表示破解一个算法需要2的N次方次运算，一般来说十几位的安全强度的破解时间只需要几分钟，如果是128位的安全强度即使是10000亿台现在普通计算能力的计算机也需要一千万个10亿年，80位的安全强度同样的条件需要38年

关于安全强度业界内最新推荐的三个常用指标是

* 美国的NIST（国家标准技术研究所）
* 德国的BSI（联邦信息安全办公室）
* 欧洲的ECRYPT-CSA（欧洲卓越密码网络）

| 安全强度 |              NIST建议              |      BSI建议       |           ECRYPT-CSA建议           |
| :------: | :--------------------------------: | :----------------: | :--------------------------------: |
|    80    | 仅遗留系统可使用，不建议用于新系统 |       不推荐       | 仅遗留系统可使用，不建议用于新系统 |
|   112    |          仅用于2030年之前          |       不推荐       |               不推荐               |
|   128    |         可以用于2030年之前         |       不推荐       |               不推荐               |
|   128    |         可以用于2030年之后         | 可以用于2020年之后 |         可以用于2028年之前         |
|   256    |         可以用于2030年之后         | 可以用于2020年之后 |         可以用于2068年之前         |



# 单向散列函数

单向散列函数其实可以分成两个部分

* 单向函数：正向容易计算，逆向运算困难的函数

  > 单向函数只是逆向运算很困难，并不是不能逆向计算，或者是该算法还没有被破解，一般的破解单向函数的方法是利用彩虹表（就是先把单向函数的结果计算出来，存到一个数据库中，破解时直接进行查找）

* 散列函数：可以把任意大小的数据，转换成固定长度的数据的函数，转换后的数据被称为散列值

  > 因为散列函数经常被人直译为哈希函数，所以我们也可以称散列值为哈希值，一般的hash函数只是一个散列函数，并不是一个单向函数，单向函数还要满足逆向运算困难这一特点

  * 散列值碰撞：当不同的输入出现相同的散列值的时候，这种情况就被称为散列值碰撞，如果出现散列碰撞就会影响性能，解决散列碰撞一般有两个思路
    * 修改散列值的长度，散列值越长，存在相同的散列值的概率就越小，发生碰撞的可能性越小（但是散列值越长，计算的时间也就越久）
    * 修改散列函数的逻辑，使结果的散列值尽可能的平均

单向散列函数既是一个单向函数，也是一个散列函数，它不仅满足单向函数的要求，还要满足散列函数的要求

* 逆向运算困难
* 构造碰撞困难

## 现行的单向散列算法

| 单向散列函数 | 安全强度 | 现在能用吗 |
| :----------: | :------: | :--------: |
|     MD2      |    -     |    退役    |
|     MD5      |   <=18   |    退役    |
|    SHA-0     |   <34    |    退役    |
|    SHA-1     |   <58    |    遗留    |
|   SHA-224    |   112    |    遗留    |
|   SHA-256    |   128    |    现行    |
|   SHA-384    |   192    |    现行    |
|   SHA-512    |   256    |    现行    |
|  SHA512/224  |   112    |    现行    |
|  SHA512/256  |   128    |    现行    |
|   SHA3-224   |   112    |    遗留    |
|   SHA3-256   |   128    |    现行    |
|   SHA3-384   |   192    |    现行    |
|   SHA3-512   |   256    |    现行    |

## 长度延展攻击

### MD结构

MD结构是Ralph Merkle在1979年的博士论文中描述的。因为Ralph Merkle 和 Ivan Damgård 分别证明了这个结构的合理性，所以这个结构被称为Merkle–Damgård结构。

* MD结构首先对输入消息进行填充，让消息变成固定长度的整数倍（比如512或者1024）。这是因为压缩算法是不能对任意长度的消息进行处理的，所以在处理之前必须进行填充。
* 将消息分成一个一个的block，前一个block 运算出来的值会跟下一个block再次进行运算。

### 攻击原理

把消息分成一个一个block这种结构可以很方便的进行长度延展攻击。前提是我们需要知道原消息的长度，我们只要知道消息的长度

* 我们就可以在原消息的基础上填充零，将原消息构建成block的整数倍之后
* 再在消息的基础上添加自己的攻击信息，因为前一个block运算的值会跟下一个block再次运算，这样就能篡改原消息

### 单向散列函数的用途

**不要单纯使用单向散列函数来处理既包含机密信息，又包含公开信息的数据**

如果我们要使用机密数据产生数据的签名，我们应该使用设计好的，经过验证的算法，比如消息验证码（Message Authentication Code）简称MAC，和基于单向散列函数的消息验证码（Hash-bash Message Authentication Code）Hmac

所以单向散列函数的应用场景主要是以下几种

* 校验数据完整性
* 数字签名，和非对称密钥及其算法结合使用
* 消息验证码，和对称密钥及其算法结合使用
* 生成伪随机数
* 生成对称密钥

# 对称加密

对称加密的算法是公开的，但是密钥是保密的

对称密钥算法按照发布的时间排序分别是DES，RC2，RC4，3DES，Camellia-128，Camellia-192，Camellia-256，AES-128，AES-192，AES-256，ChaCha20

> Cammellia-128之前的对称加密算法都已经过时了，不推荐使用

### 序列算法和分组算法

RC4和ChaCha20没有数据分块，而3DES和AES有数据分块，这是因为RC4和ChaCha20是序列算法，3DES和AES是分组算法

* 进行数据分组，然后密钥和数据组进行运算，这就是分组算法（分组就需要填充数据）

* 不进行分组，按照数据原始大小进行运算，这就是序列算法

  > 序列算法的基本思路，就是从对称密钥里推导出一段和明文数据长度相等的密钥序列，然后密钥序列和明文进行亦或运算得到密文，和密文进行异或得到明文
  >
  > 所以序列算法的关键就是怎么就是怎么从固定长度的对称密钥推导出参与运算的任意长度的密钥序列

