密码学最基础的分支有三个

* 单向散列：可以对消息进行完整性验证
* 对称密码：用来加密解密
* 非对称密码：解决授权和认证的问题

密码学要解决的问题

* 身份识别，身份认证和授权
* 信息的机密性，完整性，可用性

# 安全强度

N位的安全强度表示破解一个算法需要2的N次方次运算，一般来说十几位的安全强度的破解时间只需要几分钟，如果是128位的安全强度即使是10000亿台现在普通计算能力的计算机也需要一千万个10亿年，80位的安全强度同样的条件需要38年

关于安全强度业界内最新推荐的三个常用指标是

* 美国的NIST（国家标准技术研究所）
* 德国的BSI（联邦信息安全办公室）
* 欧洲的ECRYPT-CSA（欧洲卓越密码网络）

| 安全强度 |              NIST建议              |      BSI建议       |           ECRYPT-CSA建议           |
| :------: | :--------------------------------: | :----------------: | :--------------------------------: |
|    80    | 仅遗留系统可使用，不建议用于新系统 |       不推荐       | 仅遗留系统可使用，不建议用于新系统 |
|   112    |          仅用于2030年之前          |       不推荐       |               不推荐               |
|   128    |         可以用于2030年之前         |       不推荐       |               不推荐               |
|   128    |         可以用于2030年之后         | 可以用于2020年之后 |         可以用于2028年之前         |
|   256    |         可以用于2030年之后         | 可以用于2020年之后 |         可以用于2068年之前         |



# 单向散列函数

单向散列函数其实可以分成两个部分

* 单向函数：正向容易计算，逆向运算困难的函数

  > 单向函数只是逆向运算很困难，并不是不能逆向计算，或者是该算法还没有被破解，一般的破解单向函数的方法是利用彩虹表（就是先把单向函数的结果计算出来，存到一个数据库中，破解时直接进行查找）

* 散列函数：可以把任意大小的数据，转换成固定长度的数据的函数，转换后的数据被称为散列值

  > 因为散列函数经常被人直译为哈希函数，所以我们也可以称散列值为哈希值，一般的hash函数只是一个散列函数，并不是一个单向函数，单向函数还要满足逆向运算困难这一特点

  * 散列值碰撞：当不同的输入出现相同的散列值的时候，这种情况就被称为散列值碰撞，如果出现散列碰撞就会影响性能，解决散列碰撞一般有两个思路
    * 修改散列值的长度，散列值越长，存在相同的散列值的概率就越小，发生碰撞的可能性越小（但是散列值越长，计算的时间也就越久）
    * 修改散列函数的逻辑，使结果的散列值尽可能的平均

单向散列函数既是一个单向函数，也是一个散列函数，它不仅满足单向函数的要求，还要满足散列函数的要求

* 逆向运算困难
* 构造碰撞困难

## 现行的单向散列算法

| 单向散列函数 | 安全强度 | 现在能用吗 |
| :----------: | :------: | :--------: |
|     MD2      |    -     |    退役    |
|     MD5      |   <=18   |    退役    |
|    SHA-0     |   <34    |    退役    |
|    SHA-1     |   <58    |    遗留    |
|   SHA-224    |   112    |    遗留    |
|   SHA-256    |   128    |    现行    |
|   SHA-384    |   192    |    现行    |
|   SHA-512    |   256    |    现行    |
|  SHA512/224  |   112    |    现行    |
|  SHA512/256  |   128    |    现行    |
|   SHA3-224   |   112    |    遗留    |
|   SHA3-256   |   128    |    现行    |
|   SHA3-384   |   192    |    现行    |
|   SHA3-512   |   256    |    现行    |

## 长度延展攻击

### MD结构

MD结构是Ralph Merkle在1979年的博士论文中描述的。因为Ralph Merkle 和 Ivan Damgård 分别证明了这个结构的合理性，所以这个结构被称为Merkle–Damgård结构。

* MD结构首先对输入消息进行填充，让消息变成固定长度的整数倍（比如512或者1024）。这是因为压缩算法是不能对任意长度的消息进行处理的，所以在处理之前必须进行填充。
* 将消息分成一个一个的block，前一个block 运算出来的值会跟下一个block再次进行运算。

### 攻击原理

把消息分成一个一个block这种结构可以很方便的进行长度延展攻击。前提是我们需要知道原消息的长度，我们只要知道消息的长度

* 我们就可以在原消息的基础上填充零，将原消息构建成block的整数倍之后
* 再在消息的基础上添加自己的攻击信息，因为前一个block运算的值会跟下一个block再次运算，这样就能篡改原消息

### 单向散列函数的用途

**不要单纯使用单向散列函数来处理既包含机密信息，又包含公开信息的数据**

如果我们要使用机密数据产生数据的签名，我们应该使用设计好的，经过验证的算法，比如消息验证码（Message Authentication Code）简称MAC，和基于单向散列函数的消息验证码（Hash-bash Message Authentication Code）Hmac

所以单向散列函数的应用场景主要是以下几种

* 校验数据完整性
* 数字签名，和非对称密钥及其算法结合使用
* 消息验证码，和对称密钥及其算法结合使用
* 生成伪随机数
* 生成对称密钥

# 对称加密

对称加密的算法是公开的，但是密钥是保密的

对称密钥算法按照发布的时间排序分别是DES，RC2，RC4，3DES，Camellia-128，Camellia-192，Camellia-256，AES-128，AES-192，AES-256，ChaCha20

> Cammellia-128之前的对称加密算法都已经过时了，不推荐使用

### 序列算法和分组算法

RC4和ChaCha20没有数据分块，而3DES和AES有数据分块，这是因为RC4和ChaCha20是序列算法，3DES和AES是分组算法

* 进行数据分组，然后密钥和数据组进行运算，这就是分组算法（分组就需要填充数据）

* 不进行分组，按照数据原始大小进行运算，这就是序列算法

  > 序列算法的基本思路，就是从对称密钥里推导出一段和明文数据长度相等的密钥序列，然后密钥序列和明文进行亦或运算得到密文，和密文进行异或得到明文
  >
  > 所以序列算法的关键就是怎么就是怎么从固定长度的对称密钥推导出参与运算的任意长度的密钥序列

## AES加密

AES高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。是现在最流行的加密方式，AES加密属于分组算法，有多种不同的模式，主要有CBC，ECB，CTR，GCM模式

### CBC模式

CBC模式是并行的，其基本的逻辑是将明文分成多个小的block，然后每个block分别加密，最后把每个密文拼接到一起

这种模式有非常大的安全问题，因为每个密文只是拼接到一起，而且**每次相同的明文加密出来的密文的数据是一样的**

### ECB模式

ECB模式是串行的，基本逻辑是，前一个block的密文参加下一个block的密文的计算，这样相当于经过了多次加密，安全性更高，但是因为是并行加密，所以速度比较慢，**而且第一个block没有前一个block的密文，所以需要我们定义一个初始化向量（IV），不同的初始化向量会导致对同一个明文ECB模式加密出的密文不一样**

* 所以在使用ECB模式加密的时候加密函数需要三个参数：待加密的明文，密钥，初始化向量
* 而同样的使用ECB模式解密也需要三个参数：待解密的密文，密钥，初始化向量

> 最好每次加密都使用不同的初始化向量，初始化向量可以直接暴露，用明文传递即可

ECB模式对比CBC模式最大的区别就是使用了串行加密的方法，提高了安全性，同时因为初始化向量，可以让同一个明文加密出来的密文每次都不一样（因为初始化向量不一样），这样可以预防黑客使用彩虹表或者撞库的方式进行攻击

> 要从c=hash(m)逆向得到原始明文m，有三种办法：
>
> - 暴力破解法：时间成本太高。
> - 字典法：提前构建一个“明文->密文”对应关系的一个大型数据库，破解时通过密文直接反查明文。但存储一个这样的数据库，空间成本是惊人的。
> - 构建彩虹表：在字典法的基础上改进，以时间换空间。是现在破解哈希常用的办法。

ECB模式是现在最常用的模式，但是2018年之后ECB被发现了漏洞，现在更推荐使用的AES模式是GCM模式

### CTR模式

CTR模式是并行模式，不过并不是直接加密明文，而是通过每次加密的时候输入一个nonce，通过nonce和每个明文block的分组序号计算出每个分组的counte（计数器）然后对每个分组的counter分别加密生成一个字节流，最后用这个字节流和明文进行异或，得到最后的密文

* CTR是并行模式加密，速度比ECB快，但是同时也相当于降低了数据的规模，使得被破解的难度降低
* CTR是利用counter生成的字节流和明文做异或，**所以不需要对明文进行填充**

CTR模式需要三个加密参数：待加密的明文，密钥，nonce，解密也需要三个参数：待解密的密文，密钥，nonce

nonce的意思就是number once即只使用一次的数字，nonce和iv不一样，iv需要具有随机性和唯一性，也就是说下一次的iv不能被推算出来，而nonce只需要具有唯一性即nonce可以用一个自增的数字

# MAC（Message Authentication Code 消息验证码）机制

对于单纯的对称加密，解密端无法判断解密的密文是发送端发送的数据，还是被人掉包过的数据，所以需要验证发送的信息，验证一段信息需要做到以下三点

* 需要额外的信息帮助我们验证：只有要验证的信息本身，是没有办法验证这个消息的，信息本身不能自己验证自己，这个额外的信息，我们可以称之为验证信息
* 验证信息和待验证的信息之间要有关联，如果没有关联，也就意味着如果我们替换掉待验证的信息，验证信息并不受影响
* 验证信息的计算要快，数据要小

所以一个良好的MAC机制需要具有以上三个优点，最常见的就是基于单向散列函数的消息验证码HMAC（Hash-based Message Authentication Code）

HMAC其实就是有密钥的单向散列函数，在执行散列函数的过程中加入了密钥，其中HmacSHA256和HmacSHA384是当前最流行的两个HMAC算法，Hmac的核心流程为

* 加密端通过单向散列函数处理明文或者密文，生成验证消息
* 解密端通过对应的方式生成验证消息，然后对比验证消息

验证消息的生成过程大概有这三种

* 加密并验证：加密明文数据，计算明文数据的消息验证码，输出密文数据和消息验证码。安全外壳协议（SSH）就是采用的加密并验证的方案。

  > 这个方案的消息验证码，保护的是明文的信息的完整性，而不是密文信息的完整性，如果明文信息相同，它的消息验证码也是相同的，从攻击者的角度看，如果发现两个相同的消息验证码，就可以猜测明文信息大概率是相同的

* 加密后验证：加密明文数据，计算加密数据的消息验证码，输出密文数据和验证码，这个方案，我们简称为加密后验证，IPSec采用的就是加密后验证的方案

  > 只要加密算法不把相同的明文加密成相同的密文信息，它的消息验证码也是不同的，所以，这个方案并没有上面的加密并验证方案的安全问题

* 验证后加密：计算明文数据的消息验证码，加密明文数据和验证码，输出密文数据，这种方式我们简称为验证后加密，SSL协议就是采用验证后加密的方案

  > 这个方案其实是把明文和验证码看作是一个数据了，本质上和加密并验证方案差不多

加密后验证这个方案目前来说是相对最安全的，在2014年之后，无论是SSH协议还是TLS协议，都提供了加密后验证的选项，用来提高协议的安全性，其中2018年之后发布的新TLS协议，已经不再使用上述的任意一个方案

# AEAD

Authenticated Encryption with Associated Data (AEAD) 是一种同时具备保密性，完整性和可认证性的加密形式。

AEAD 产生的原因很简单，单纯的对称加密算法，其解密步骤是无法确认密钥是否正确的。也就是说，加密后的数据可以用任何密钥执行解密运算，得到一组疑似原始数据，而不知道密钥是否是正确的，也不知道解密出来的原始数据是否被替换。

因此，需要在单纯的加密算法之上，加上一层验证手段，来确认解密步骤是否正确。简单地把加密算法和认证算法组合，可以实现上述目的，**从 2008 年起，业内开始提出，需要在一个算法在内部同时实现加密和认证**

常见的 AEAD 算法如下：

- AES-128-GCM
- AES-192-GCM
- AES-256-GCM
- ChaCha20-IETF-Poly1305
- XChaCha20-IETF-Poly1305

> AES的GCM模式就是利用AES的CTR模式进行加密，然后同时利用反向散列函数做验证

# 非对称加密



