# 二分查找

二分查找的时候最重要的几个点

* while循环的跳出规则

  > while循环最容易产生出两种情况
  >
  > * 死循环
  > * 漏掉left=right相等的情况
  >
  > 这里做一下总结，默认可以把while循环都写成while(left <= right)，但是这种情况很容易发生死循环，判断是否会发生死循环的标准是，看代码里面有没有left = mid，right = mid，如果区间切换的代码里面有这两句，一般都有死循环，可以在while里面做一个判断，当遇到死循环的时候break；

* 下一轮搜索区间的判断

  > 下一轮搜索区间一定要分三种情况来讨论，即target=mid,target>mid,target<mid，可以分开分析三种情况然后再合并，这样思考的过程更清晰

* mid的计算最好用`mid = left  + (right - left) / 2`，如果直接用`mid = (left + right) / 2`，可能会有数值溢出的问题

![image-20200717143727888](https://gitee.com/syllr/images/raw/master/uPic/20210912165204N7CNl0.jpg)

## 「力扣」第 704题：[二分查找](https://leetcode-cn.com/problems/binary-search/)

```java
class Solution {
    public int search(int[] nums, int target) {
        //定义左边界和右边界
        int left = 0;
        int right = nums.length - 1;
        //二分法使用循环
        while (left <= right) {
          	int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else {
                if (nums[mid] > target) {
                    //在左边
                    right = mid - 1;
                } else {
                    //在右边
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
}
```

* 退出循环的条件是`left <= right`

* 

## 「力扣」第 35题：[搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/submissions/)

分析：这道题要求我们在一个有序数组里查找插入元素的位置，那么什么是插入元素的位置呢？我们看示例。

* 示例 1：目标元素 55 在有序数组 [1,3,5,6] 里，下标为 22，输出 22；
* 示例 2：目标元素 22 不在有序数组 [1,3,5,6] 里，返回 33 的下标 11 ，我们可以知道，如果数组中不存在目标元素，返回第 1 个严格大于目标元素的数值的下标；
* 示例 3：目标元素 77 不在有序数组 [1,3,5,6] 里。特别地，77 比最后一个元素 66 还大，返回最后一个元素的下标 +1+1；
* 示例 4：目标元素 00 不在有序数组 [1,3,5,6] 里。特别地，00 比第一个元素 11 还小，返回第 1 个元素的下标 00。

由上面 4 个示例，知道题目要我们找的是 大于等于目标元素的第 11 个下标。

```java
public class Solution {
    /**
     * 查找大于等于目标元素的第一个下标
     */
    public int searchInsert(int[] nums, int target) {
        int length = nums.length;
        //特判
        if (length == 0) {
            return 0;
        }
        if (nums[length - 1] < target) {
            return length;
        }
        //设置左右
        int left = 0;
        int right = length - 1;
	      //因为在选取下一轮搜索区间时，right=mid - 1; left = mid + 1;都是有前进或者后退的，所以while循环里面的条件一定是left <= right
	      //不然当left加一，或者right减一之后，刚好left==right，如果while(left < right)，就会漏掉这种情况
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (target == nums[mid]) {
                return mid;
            }
            if (target < nums[mid]) {
                //下一轮搜索区间[left, mid - 1]
                right = mid - 1;
            } else {
                //下一轮搜索区间[mid, right]
                left = mid + 1;
            }
        }
      	//最后判断能否在数组中查找到target，如果没有找到，则直接返回第一个大于目标元素的下标
        if (target > nums[left]) {
            return left + 1;
        }
        return left;
    }
}
```

## 「力扣」第 34 题：[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

* 第一种先通过二分查找任意一个target的下标，然后向前向后遍历，再找到元素的第一个和最后一个位置

  ```java
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          //先用二分查找随便查找任意一个target所在的下标，如果返回-1，说明target没有在nums数组中，直接返回[-1, -1]
          int index = binarySearch(nums, target);
          if (index < 0) {
              return new int[]{-1, -1};
          }
  
          int[] result = new int[2];
          int leftIdx = index;
          int rightIdx = index;
          //任意找到一个target的下标之后，向前遍历，找到元素的第一个位置，注意数组下标的不要越界
          while (leftIdx > 0 && target == nums[leftIdx]) {
              if (target == nums[leftIdx - 1]) {
                  leftIdx--;
              } else {
                  break;
              }
          }
          //向后遍历找到元素的最后一个位置，注意数组下标不要越界
          while (rightIdx < nums.length - 1 && target == nums[rightIdx]) {
              if (target == nums[rightIdx + 1]) {
                  rightIdx++;
              } else {
                  break;
              }
          }
          result[0] = leftIdx;
          result[1] = rightIdx;
          return result;
      }
  
      int binarySearch(int[] nums, int target) {
          if (nums.length == 0) {
              return -1;
          }
  
          int left = 0;
          int right = nums.length - 1;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              if (nums[mid] == target) {
                  return mid;
              }
              if (target > nums[mid]) {
                  left = mid + 1;
              } else {
                  right = mid - 1;
              }
          }
          return -1;
      }
  }
  ```

* 分别通过二分查找法分别找到第一个元素和最后一个元素的位置

  ```java
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          if (nums.length == 0) {
              return new int[]{-1, -1};
          }
          int firstIndex = searchFirst(nums, target);
          if (firstIndex < 0) {
              return new int[]{-1, -1};
          }
          int lastIndex = searchLast(nums, target);
          return new int[]{firstIndex, lastIndex};
      }
  
      /**
       * 找到第一个元素的位置
       */
      int searchFirst(int[] nums, int target) {
          int left = 0;
          int right = nums.length - 1;
          while (left <= right) {
              if (left == right && nums[left] == target) {
                  return left;
              }
              int mid = left + (right - left) / 2;
              /*
                分为三种情况,
                如果刚好target==mid，而我们需要找的是第一个元素，现在mid可能是第一个也可能是比第一个大的元素
                所以下一次需要查找的区间，应该包含mid，而区间整体向左
               */
              if (nums[mid] == target) {
                  //因为right=mid，同时while(left <= right)，在这种情况下会会出现死循环，所以要在第21行添加判断，跳出死循环
                  right = mid;
              }
  
              /*
              如果target > mid，那么第一个元素所在的位置也是大于mid
               */
              if (nums[mid] < target) {
                  left = mid + 1;
              }
  
              if (nums[mid] > target) {
                  right = mid - 1;
              }
  
          }
          return -1;
      }
  
      /**
       * 找到最后一个元素的位置
       */
      int searchLast(int[] nums, int target) {
          int left = 0;
          int right = nums.length - 1;
          while (left <= right) {
              if (left == right && nums[right] == target) {
                  return right;
              }
              int mid = left + (right - left + 1) / 2;
              if (nums[mid] == target) {
                  //因为left=mid，同时while(left <= right)，在这种情况下会会出现死循环，所以要在第57行添加判断，跳出死循环
                  left = mid;
              }
  
              if (nums[mid] > target) {
                  right = mid - 1;
              }
  
              if (nums[mid] < target) {
                  left = mid + 1;
              }
          }
          return -1;
      }
  }
  ```

## 「力扣」第 153 题：[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)