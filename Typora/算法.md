# 基础排序算法

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210913223142ufqyZs.png)

## 选择排序

选择排序」每一轮都选取「未排定的部分」的最小元素，然后将它 交换 到「未排定的部分」的第 1 个位置。下面我们通过一个具体的例子，说明选择排序的执行步骤。

例：将数组 [8, 3, 9, 6, 4, 1, 5, 2, 10, 7] 升序排序。

* 首先经过一次扫描，通过逐个比较，找到整个数组中最小的元素 1，把它交换到这个数组的开头，交换以后，1 就呆在了最终应该在的位置；
* 接下来，继续扫描未排定的部分，选出最小的元素 2，把它交换到未排定的部分的第 1 个位置，这个位置就是 2 这个元素最终应该呆的位置；
* 接下来的操作，我们就不赘述了。直到「未排定的部分」只剩下一个元素，此时，我们就不用比较了，它一定是整个数组中最大的那个元素。
* 到此为止，我们就得到了原始数组的升序排序结果。

### 打擂台算法

选择排序有两个循环，所以算法复杂度是O(n2)，外层循环的作用是计算第i个大小的元素，而内层的循环的作用是

选出「未排定部分」的最小元素，然后交换到未排定区域的起始位置，因此这个最小元素的下标很重要，这个代码的写法是一种非常经典的写法，叫做「假设修正法」：先假设「未排定部分」的 1 个元素是「未排定部分」的最小元素，如果扫描到的元素的值比当前 minIndex 所指向的元素还要严格小，就把 minIndex 的值更新为这个更小的元素的下标，这一趟扫描完以后，把 minIndex 所指向的元素交换到未排定部分的起始位置。这种一趟扫描选出最值的方法，有一个很形象的名字叫：**打擂台算法；**

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

### 1. 算法步骤

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。

### 2. 动图演示

![img](https://gitee.com/syllr/images/raw/master/uPic/20210914100708zo8y72.gif)

### [912. 排序数组（选择排序解答）](https://leetcode-cn.com/problems/sort-an-array/)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        //选择排序
        //选择排序有两个循环，外层循环从第二个元素开始，因为第一个元素按照【假设修正法】是假定为最小的，外层循环的结束是length - 1，因为剩下的最后一个元素一定是最大的元素
        if (nums.length == 1) {
            return nums;
        }
        for (int index = 1; index < nums.length; index++) {
            //设置内层循环前第一个元素为假设最小
            int minIndex = index - 1;
            //内层循环是要计算所有剩下的元素的最小，所以结束是length
            for (int innerIndex = index; innerIndex < nums.length; innerIndex++) {
                //假设最小元素要放在内层循环，因为内层循环会替换他
                int min = nums[minIndex];
                int num = nums[innerIndex];
                if (num < min) {
                    //交换假设元素
                    swap(nums, innerIndex, minIndex);
                }
            }
        }
        return nums;
    }

    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```

选择排序是一个效率不高的算法，效率不高的原因是：每一次循环没有为下一次循环记录更多的信息。事实上，有一个数据结构，能够帮助我们在每次「未排定的部分」里快速地选择出当前最小的元素，这样的数据结构是「堆」，进而衍生出的「堆排序」就是「选择排序」的优化排序算法。

选择排序的算法复杂度是O(n2)，在所有排序中属于时间复杂读最高的，但是有一个优点是交换次数最少，如果有列表中交换元素成本很高的场景可以用选择排序

## 冒泡排序

冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。

### 1. 算法步骤

* 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 2. 动图演示

![img](https://gitee.com/syllr/images/raw/master/uPic/20210913224011hImLzJ.gif)

### 3. 什么时候最快

当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

### 4. 什么时候最慢

当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。

```java
class Solution {
    public int[] sortArray(int[] nums) {
        if (nums.length == 0) {
            return nums;
        }
        //冒泡排序
        //冒泡排序有两层循环，算法复杂度为O(n2)
        for (int index = 0; index < nums.length; index++) {
            //因为冒泡排序是每次把当前剩下元素集合的最大值冒泡到最右边，所以内层循环应该是右边界每次减一
            //因为要同时判断两个元素的大小，所以内层循环要从1开始
            for (int innerIndex = 1; innerIndex < nums.length - index; innerIndex++) {
                if (nums[innerIndex] < nums[innerIndex - 1]) {
                    swap(nums, innerIndex, innerIndex - 1);
                }
            }
        }
        return nums;
    }

    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```



### [912. 排序数组（冒泡排序解答）](https://leetcode-cn.com/problems/sort-an-array/)

## 插入排序

![image-20200715140200321](https://gitee.com/syllr/images/raw/master/uPic/20210913222759iGU9W1.jpg)

插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

### 1. 算法步骤

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

### 2. 动图演示

![img](https://gitee.com/syllr/images/raw/master/uPic/20210914111126SUkhhe.gif)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        if (nums.length == 0) {
            return nums;
        }
        //插入排序
        //插入排序两层循环
        for (int index = 1; index < nums.length; index++) {
            int tmp = nums[index];
            for (int innerIndex = index - 1; innerIndex >= 0; innerIndex--) {
                //需要把要查找插入位置的元素用一个变量保存，因为后面这个位置会被别的元素占用
                //找到插入位置
                if (nums[innerIndex] > tmp) {
                    //要查找位置的元素比当前元素小，说明要查找的元素应该在当前对比元素的前面，所以当前元素要右移
                    swap(nums, innerIndex, innerIndex + 1);
                } else {
                    //不用设置，因为这个时候经过交换已经就是tmp
                    break;
                }
            }
        }
        return nums;
    }

    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```

## 希尔排序

![image-20200717162404234](https://gitee.com/syllr/images/raw/master/uPic/20210914142340RmJHRG.jpg)

希尔排序每一轮将数组按照间隔分成若干子序列，再对各个子数组分别使用插入排序，直至最后执行一次间隔为 1 的插入排序，整个数组就有序了。

![03-03-02](https://gitee.com/syllr/images/raw/master/uPic/20210914142522tBPGxv.png)

希尔排序克服了插入排序的缺点，一个较小的数可以很快来到数组靠前的部分。间隔的选择是从大到小直至为 1。间隔越大，每一次执行插入排序的元素越少；反之，间隔越小，每一次执行插入排序的元素越多。在最开始的时候参与插入排序的元素个数是较少的，利用了插入排序的优点。之后的每一轮，虽然间隔减少，但是数组越来越有序，插入排序可以较快完成。

```java
class Solution {
    public int[] sortArray(int[] arrays) {
        //增量每次都/2
        for (int step = arrays.length / 2; step > 0; step /= 2) {

            //从增量那组开始进行插入排序，直至完毕
            //这个地方有点反直觉，希尔排序是要通过gap把原来的数组分成子序列，然后在子序列里面使用插入排序
            //从逻辑直觉上，应该是把每个单独的子序列找出来，然后每个子序列单独进行插入排序
            //但是int index = step; index < arrays.length; index++;通过最外层的循环，以及内层循环的step，把这个顺序打乱了，看起来违反直觉
            for (int index = step; index < arrays.length; index++) {

                int innerIndex = index;
                int temp = arrays[innerIndex];

                // innerIndex - step 就是代表与它同组隔壁的元素
                while (innerIndex - step >= 0 && arrays[innerIndex - step] > temp) {
                    arrays[innerIndex] = arrays[innerIndex - step];
                    innerIndex = innerIndex - step;
                }
                arrays[innerIndex] = temp;
            }
        }
        return arrays;
    }
}
```

## 排序算法的评价指标

![image-20200717162910714](https://gitee.com/syllr/images/raw/master/uPic/20210914143611udnvOT.jpg)

- 时间复杂度：分得细一点，可以是「最差时间复杂度」、「平均时间复杂度」、「最好时间复杂度」；
- 额外空间复杂度；
- 是否是原地排序；
- 稳定性；

# 循环不变量

![image-20200717163610228](https://gitee.com/syllr/images/raw/master/uPic/20210914170228B8Q5oa.jpg)

### 什么是循环不变量

循环不变量通常来说是一种语言描述，是一个抽象的概念，描述了在循环过程中，我们所设计的变量保持不变的性质。其中：

* 量：表示了一个或者若干个变量；
* 循环不变：这若干个变量在循环的过程中，保持了它们各自的性质；
* 遍历的过程分为 3 个阶段：初始时、循环过程中、结束时。考虑清楚这 3 个阶段的逻辑，能够让我们更清楚变量的边界在哪里。

### 具体例子

#### 选择排序的循环不变量

语言描述：区间 [0, i) 有序，即 i 之前的元素有序，并且它们中的元素都放在了 最终 应该在的位置。

我们考察选择排序的 3 个阶段：

* 初始时：i = 0 区间 [0, i) 为空；
* 循环过程中：我们把 i 到数组末尾的区间 [i, len - 1] 的最小的元素交换到 i 的位置，然后 i 自增 11，这样一来，在下一轮循环开始之前，区间 [0, i) 有序的性质仍然成立；
* 结束时：i = len，区间 [0, len) 有序，即区间 [0, len - 1] 有序，算法的有效性得证。

#### 插入排序的循环不变量

语言描述：区间 [0, i) 有序，这里同样是设计成 i 之前的元素有序，只不过不要求这些元素一定放置在排好序后最终应该在的位置。

我们考察选择排序的 3 个阶段：

* 初始时：i = 0 区间 [0, i) 为空；
* 循环过程中：我们把 i 位置的元素插入到区间 [0, i) 中，然后 i 自增 11，这样一来，在下一轮循环开始之前，区间 [0, i) 有序这条性质仍然成立；
* 结束时：i = len，区间 [0, len) 有序，即区间 [0, len - 1] 有序，算法的有效性得证。

#### 二分查找的循环不变量

「下一轮搜索区间在 `[left, mid]` 」就是关于二分查找算法的循环不变量。

### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //使用循环不变量的方法解题
        //首先确认循环不变量的定义：[0, i)的数组的所有0都在末尾
        for (int index = 0; index < nums.length; index++) {
            //[0, index)要满足循环不变量的条件
            //随着index的增加，要每次判断nums[index]是否满足循环不变量条件
            //假设[0, index)满足条件，现在只需要判断nums[index]加入数组之后应该放在哪个位置
            //如果nums[index]不为0，为了保持相对顺序不变，应该放在[0, index]中第一个零的前面
            //如果nums[index]为0，则直接放在[0, index]的最后一个，刚好就是现在nums[index]所在的位置，不需要进行交换
            //所以首先要做的是判断nums[index]是否等于0
            if (nums[index] == 0) {
                //不做处理，index直接加一就行
            } else {
                //需要找到[0, index]第一个0，把nums[index]放到第一个0前面，所以[0, index)要从后往前遍历，然后把所有的0都向后移动一位
                //（这就是插入排序的逻辑）
                for (int innerIndex = index - 1; innerIndex >= 0; innerIndex--) {
                    if (nums[innerIndex] == 0) {
                        swap(nums, innerIndex, innerIndex + 1);
                    }
                }
            }
        }
    }

    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```

### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        //循环不变量设定为[0, index)的元素不重复，需要两个变量
        //index表示不重复数组的最后一个元素下标
        //scanIndex表示循环的索引下标
        //因为数组只有一个元素时，必定不重复，所以从1开始循环
        int index = 0;
        for (int scanIndex = 1; scanIndex < nums.length; scanIndex++) {
            if (nums[scanIndex] == nums[scanIndex - 1]) {
                //说明有重复元素，scanIndex++，但是index不变，因为没有新的元素
            } else {
                index++;
                nums[index] = nums[scanIndex];
            }
        }
        //返回的是长度，索引要加一
        return index + 1;
    }
}
```



# 高级排序算法（算法复杂度小于O(n2)）

## 归并排序

![image-20200720232259726](https://gitee.com/syllr/images/raw/master/uPic/20210914170927NMghcB.jpg)

### 归并排序体现的算法思想：分而治之（Divide and Conquer）

分而治之思想有以下三个步骤：

* 分解（Divide）：将原问题划分为一些子问题，子问题的形式与原问题相同，只是规模更小；
* 解决（Conquer）：递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解；
* 合并（Combine）：将子问题的解组合成原始问题的解。

![img](https://gitee.com/syllr/images/raw/master/uPic/20210914224904JwJcp8.png)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        //归并排序
        //归并排序的前提是要两个数组分别有序，再合并，所以首先要保证合并的两个数组都是有序的
        //当数组只有一个元素的时候一定是有序的，所以通过分而治之的思想，将一个无序数组排序转化为两个有序数组做归并
        //而两个有序数组则是再分别通过比自己还小的另外两个有序数组归并，这是一个递归的过程
        //递归最终停止的条件是数组的元素个数为1
        return mergerSort(nums);
    }

    private int[] mergerSort(int[] nums) {
        if (nums.length == 1) {
            //递归第二步，解决：递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解；
            //只有一个元素，说明就是单调的，停止递归，直接求解（就是直接返回）
            return nums;
        }

        int mid = (nums.length) / 2;
        //数组会分为两个数组[0, mid] [mid + 1, length];
        //分别对这两个数组进行递归

        //递归第一步：分解
        int[] numsA = new int[mid];
        int[] numsB = new int[nums.length - mid];
        //为了方便计算，没有用原地排序，重新开辟了空间用两个新的数组，追求效率可以用原地
        for (int index = 0; index < nums.length; index++) {
            if (index < mid) {
                numsA[index] = nums[index];
            } else {
                numsB[index - mid] = nums[index];
            }
        }

        numsA = mergerSort(numsA);
        numsB = mergerSort(numsB);

        //递归第三步：合并
        return merger(numsA, numsB);
    }

    /**
     * 数组归并过程
     */
    private int[] merger(int[] numsA, int[] numsB) {
        //执行归并的过程
        int[] result = new int[numsA.length + numsB.length];
        int numsAIndex = 0;
        int numsBIndex = 0;
        int resultIndex = 0;
        while (resultIndex < result.length) {
            //判断数组越界
            if (numsAIndex >= numsA.length) {
                result[resultIndex] = numsB[numsBIndex];
                numsBIndex++;
                resultIndex++;
                continue;
            }
            if (numsBIndex >= numsB.length) {
                result[resultIndex] = numsA[numsAIndex];
                numsAIndex++;
                resultIndex++;
                continue;
            }

            if (numsA[numsAIndex] < numsB[numsBIndex]) {
                result[resultIndex] = numsA[numsAIndex];
                numsAIndex++;
            } else {
                result[resultIndex] = numsB[numsBIndex];
                numsBIndex++;
            }
            resultIndex++;
        }

        return result;
    }
}
```

### 归并排序优化

![归并排序优化](https://gitee.com/syllr/images/raw/master/uPic/20210914213227yacdWw.jpg)

## 快速排序

### 快排的基本思路

快速排序也是使用了**分而治之**的方式来进行排序

![image-20210914230320340](https://gitee.com/syllr/images/raw/master/uPic/20210914230321WwFctL.png)

* 快速排序现在数组里选择一个元素（随机一个，最方便的就选第一个）

![image-20210914230505764](https://gitee.com/syllr/images/raw/master/uPic/20210914230507oQIRd3.png)

* 这里选择了第一个元素4作为**切分元素**意思是在这个元素的左边都小于等于这个元素，在这个元素右边都大于这个元素（循环不变量）

![image-20210914230653375](https://gitee.com/syllr/images/raw/master/uPic/202109142306550nvm7g.png)

* 将剩下的[1, end]的所有元素经过一次遍历达到这样的效果，这个数组的前半部分的所有元素都小于等于4，后半部分的所有元素都大于4

![image-20210914231224949](https://gitee.com/syllr/images/raw/master/uPic/20210914231226NndjKX.png)

* 然后我们将**切分元素**和[1, end]中前半部分小于4部分的最后一个元素交换位置。这样4的位置就是最终排好序所在的位置上，以后也不会动了
* 接下来需要递归的把4前面和4后面的所有元素执行类似的操作，每一次这样的操作都可以确定一个元素的位置，直到最后递归的数组中只有一个元素的时候，这个数组一定是有序的，就可以停止递归，所以区间里只有一个元素就是递归终止条件
* 这样通过遍历一个数组的子区间再排好序到达最终有序的方法叫做partition

### Partition的具体过程

![image-20210914232005181](https://gitee.com/syllr/images/raw/master/uPic/20210914232007kOyR5A.png)

1. 使用黄色表示小于等于4的元素，绿色表示严格大于4的元素

![image-20210914232057380](https://gitee.com/syllr/images/raw/master/uPic/20210914232059MPiUkp.png)

2. [5]数组中第一个元素5是大于4的元素，因为现在只有一个元素，所以不需要移动位置

![image-20210914232236724](https://gitee.com/syllr/images/raw/master/uPic/20210914232238HwyoG2.png)

3. [5, 1]数组中1是小于4的元素，但是因为我们规定在[5, 1]这个数组中大于4的元素应该在前半部分，所以应该把当前元素1（这个元素小于4）和**第一个大于4的元素**交换位置，即1和5交换位置

![image-20210914232519136](https://gitee.com/syllr/images/raw/master/uPic/202109142325219Lt1sY.png)

![image-20210914232527507](https://gitee.com/syllr/images/raw/master/uPic/20210914232528QwDh6d.png)

4. 1和5交换位置之后，判断下一个元素6和4的大小，6大于4，应该在数组的后半部分，所以直接将数组[1, 5]，变成[1, 5, 6]即可，不需要做移动

![image-20210914232728131](https://gitee.com/syllr/images/raw/master/uPic/20210914232729wKLfA6.png)

5. 元素7和元素6同理

![image-20210914232756984](https://gitee.com/syllr/images/raw/master/uPic/20210914232758fnCuqH.png)

6. 元素3小于4，应该放在数组的前半部分，所以和步骤三中同理，将元素3和当前数组中第一个大于元素4的元素（后半部分的第一个元素）交换位置

![image-20210914233042231](https://gitee.com/syllr/images/raw/master/uPic/20210914233044SJOW4e.png)

7. 最后一个元素2和步骤三，步骤六同理，将元素2和当前数组中第一个大于元素4的元素（后半部分的第一个元素）交换位置

![image-20210914233221112](https://gitee.com/syllr/images/raw/master/uPic/20210914233222TcvwwL.png)

![image-20210914233229799](https://gitee.com/syllr/images/raw/master/uPic/20210914233231vEpjdD.png)

8. 最后再把元素4和小于4的最后一个元素（也就是2）交换位置

![image-20210914233329852](https://gitee.com/syllr/images/raw/master/uPic/20210914233331EC6SKU.png)

### 具体代码表达

![image-20210914233613630](https://gitee.com/syllr/images/raw/master/uPic/202109142336155YZ1vr.png)

* 选择第一个元素作为切分元素，我们叫他pivot（转折点的意思）
* 使用循环变量i遍历pivot后面所有的元素
* 在遍历的过程中使用循环变量le表示pivot以后i之前遍历到的这个区间（从pivot后面第一个元素，到i元素）里所有小于等于pivot的元素部分和所有大于pivot元素部分的分界线，nums[left]代表pivot元素，nums[le]已经遍历过的区间中最后一个小于等于pivot的元素，nums[i]代表当前要和pivot比较大小的第一个元素（也就是还没有遍历的第一个元素）
* 如果nums[i] > pivot，那么i向后移动（i = i + 1）
* 如果nums[i] <= pivot，那么nums[i]和nums[le + 1]交换位置，然后le = le + 1，i = i + 1
* 直至i遍历到了末尾

```java
class Solution {
    public int[] sortArray(int[] nums) {
        //快速排序解答
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right) {
        //解答问题，当集合里面只有少量元素的时候可以直接解答，返回结果
        //当数组只有一个元素的时候说明该数组有序，直接返回
        if (left >= right) {
            return;
        }

        //分解问题
        //随意取一个数（为了方便就用第一个）作为切分元素，然后将数组里面剩余的元素中小于等于切分元素的放在前半部分，大于切分元素的放在后半部分
        int pivot = nums[left];
        //le表示数组中最后一个比pivot小的元素的下标
        int le = left;
        for (int index = left + 1; index <= right; index++) {
            if (nums[index] <= pivot) {
                //该元素小于等于pivot，应该被放在前半部分
                //le + 1
                le = le + 1;
                swap(nums, le, index);
            } else {
                //该元素大于pivot，应该被放在后半部分，index加一就行了
            }
        }
        //循环结束之后，将pivot和前半部分的最后一个元素交换位置
        swap(nums, left, le);

        //然后再分别把前半部分和后半部分进行递归
        quickSort(nums, left, le - 1);
        quickSort(nums, le + 1, right);
        //因为直接在原数组上做swap，所以没有合并的过程
    }

    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```

### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        //要求只需要找到第K个最大元素，并不需要所有前K个元素都排好序，所以可以用快速排序的partition的思路
        //使用减治的原理，通过快速排序来将分区排序，排除无效的分区
        return findTopK(nums, 0, nums.length - 1, k);
    }

    private int findTopK(int[] nums, int left, int right, int k) {
        if (left == right) {
            return nums[left];
        }
        int pivot = nums[left];
        //前半部分最后一个元素的位置，最后一个比pivot小的数据下标
        int gt = left;
        for (int index = left + 1; index <= right; index++) {
            int num = nums[index];
            if (num > pivot) {
                //交换比pivot小的第一个元素
                gt = gt + 1;
                swap(nums, gt, index);
            } else {
                //pivot比当前元素大，所以index直接右移，可以不写else，但是为了写注释还是写了else
            }
        }
        //因为会和前半部分的最后一个元素交换位置，可以直接比较下
        if (gt == k - 1) {
            //如果相等就直接找到元素了，直接返回
            return nums[left];
        } else {
            //如果不是这个元素在第k个元素，要交换位置
            swap(nums, left, gt);
        }

        if (gt > (k - 1)) {
            return findTopK(nums, left, gt - 1, k);
        } else {
            return findTopK(nums, gt + 1, right, k);
        }
    }

    private void swap(int[] nums, int start, int end) {
        if (start == end) {
            return;
        }
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```



# 减而治之和分而治之

减而治之和分而治之的做法都是缩小问题的规模，来最终获取问题的解，但是两者的做法所不同

## 减而治之

求解一个大规模的问题，可以将其划分为两个子问题，其一是平凡问题，另一个规模缩减。由子问题的解，得到原问题的解。

减而治之的核心其实是排除法，比如二分查找就是最典型的减而治之的思路，二分查找把要查找的区间分成两个区间，通过验证可以确定所要查找的元素在哪一个区间，这样就可以把问题的规模缩小，最后缩小到只有一个元素的空间。

大区间 = 答案所在区间 + 排除区间

核心逻辑是：大区间的答案 = 问题所在区间的答案

减而治之的流程为

* 分解问题：把一个大规模的问题分解成n多个小规模的问题（n=2就是二分，n=3就是三分）
* 排除区间找到答案所在区间：利用区间的单调性（或者部分单调也行）排除n-1个区间，找到答案所在的区间

## 分而治之

把一个大规模的问题，分成很多个小规模的问题分别求解，最后把所有小规模的问题的答案合并得到大规模问题的求解

大区间 = 分治区间1 + 分治区间2 + .......

核心逻辑是：大区间的答案 = merger(分治区间1的答案 + 分治区间2的答案 + ....... +分治区间n的答案)

所以分而治之有三步流程

* 分解问题：把一个大规模的问题分解成n多个小规模的问题
* 求解问题：当问题的规模足够小的时候，可以直接给出问题的答案，如果问题的规模没有到能足够给出答案的地步，再次分解问题（递归）
* 合并答案：把分治区间的答案合并成大区间的答案

# 非比较排序算法

上面提到的都是基于比较的排序方法，而接下来要介绍的「计数排序」、「基数排序」和「桶排序」都是非比较的排序方法。「非比较」是指：一个元素在排好序以后的位置，是由它自己的值决定的。「非比较」排序中蕴含了「哈希表」的思想。

## 计数排序

![img](https://gitee.com/syllr/images/raw/master/uPic/20210916003245d8E0S8.gif)

- （1）找出待排序的数组中最大和最小的元素
- （2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项
- （3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
- （4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

```java
class Solution {
    public int[] sortArray(int[] nums) {
        //首先找到数组中最大的元素
        int max = 0;
        for (int num : nums) {
            max = Math.max(num, max);
        }

        //新建数组长度为max + 1，为了让数据的值和索引对应起来所以加一
        int[] countArr = new int[max + 1];

        for (int num : nums) {
            countArr[num] = countArr[num] + 1;
        }

        //还原数组
        int numsIndex = 0;
        for (int index = 0; index < countArr.length; index++) {
            if (countArr[index] != 0) {
                for (int innerIndex = 0; innerIndex < countArr[index]; innerIndex++) {
                    nums[numsIndex] = index;
                    numsIndex++;
                }
            }
        }
        return nums;
    }
}
```

## 桶排序

桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。

桶排序的思想近乎彻底的**分治思想**。

* 桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。

* 然后基于某种映射函数f ，将待排序列的关键字 k 映射到第i个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。

* 接着将各个桶中的数据有序的合并起来 : 对每个桶B[i] 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 B[0]….B[M] 中的全部内容即是一个有序序列。

> 补充： 映射函数一般是 f = array[i] / k; k^2 = n; n是所有元素个数

为了使桶排序更加高效，我们需要做到这两点：

> 1、在额外空间充足的情况下，尽量增大桶的数量；
> 2、使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中；

同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。

### 实现逻辑

- 设置一个定量的数组当作空桶子。
- 寻访序列，并且把项目一个一个放到对应的桶子去。
- 对每个不是空的桶子进行排序。
- 从不是空的桶子里把项目再放回原来的序列中。

![v2-b29c1a8ee42595e7992b6d2eb1030f76_b](https://gitee.com/syllr/images/raw/master/uPic/20210916104645J1dp4u.gif)

![img](https://gitee.com/syllr/images/raw/master/uPic/20210916104700XQX0gi.jpg)

桶排序是计数排序的变种，它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。

算法思想和散列中的开散列法差不多，当冲突时放入同一个桶中；可应用于数据量分布比较均匀，或比较侧重于区间数量时。

桶排序最关键的建桶，如果桶设计得不好的话桶排序是几乎没有作用的。通常情况下，上下界有两种取法，第一种是取一个10^n或者是2^n的数，方便实现。另一种是取数列的最大值和最小值然后均分作桶.

## 基数排序

基数排序(Radix Sort)属于分配式排序，又称"桶子法"(Bucket Sort或Bin Sort)，将要排序的元素分配到某些"桶"中，以达到排序的作用。基数排序属于稳定的排序，其时间复杂度为nlog(r)m (其中r为的采取的基数,m为堆数)，基数排序的效率有时候高于其它比较性排序。

基数排序的方式可以采用**最低位优先LSD（Least sgnificant digital）法**或**最高位优先MSD（Most sgnificant digital）法**，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好，MSD的方式恰与LSD相反，是由高位数为基底开始进行分配，其他的演算方式则都相同。

以LSD为例，假设原来有一串数值如下所示：

```undefined
73, 22, 93, 43, 55, 14, 28, 65, 39, 81 
```

首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：

```undefined
分配过程：
0 
1 81
2 22
3 73 93 43
4 14
5 55 65
6
7
8 28
9 39 
```

接下来将这些桶子中的数值重新串接起来，成为以下的数列：

```undefined
收集过程：
81, 22, 73, 93, 43, 14, 55, 65, 28, 39 
```

接着再进行一次分配，这次是根据十位数来分配：

```undefined
分配过程：
0
1 14
2 22 28
3 39
4 43
5 55
6 65
7 73
8 81
9 93
```

接下来将这些桶子中的数值重新串接起来，成为以下的数列：

```undefined
收集过程：
14, 22, 28, 39, 43, 55, 65, 73, 81, 93 
```

这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。

## 堆排序

在介绍堆排序之前，首先需要说明一下，堆是个什么玩意儿。

其中每个结点的关键字都**不大于**其孩子结点的关键字，这样的堆称为**小顶堆**。

其中每个结点的关键字都**不小于**其孩子结点的关键字，这样的堆称为**大顶堆**。

举例来说，对于n个元素的序列{R0, R1, ... , Rn}当且仅当满足下列关系之一时，称之为堆：

**(1) Ri <= R2i+1** **且 Ri <= R2i+2 (****小顶堆)**

**(2) Ri >= R2i+1** **且 Ri >= R2i+2 (****大顶堆)**

其中i=1,2,…,n/2向下取整; 

![img](https://gitee.com/syllr/images/raw/master/uPic/20210916143312Ax6CMI.png)

用数组就存储一个大顶堆或者小顶堆，上图就表示了用一个数组来存储小顶堆

```java
package com;

import java.util.Arrays;

/**
 * Created by chengxiao on 2016/12/17.
 * 堆排序demo
 */
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 5, 2, 6, 9, 7, 8, 0};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void sort(int[] arr) {
        //1.构建大顶堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            //从第一个非叶子结点从下至上，从右至左调整结构，第一个非叶子节点为(length / 2 - 1)
            adjustHeap(arr, i, arr.length);
        }
        
        //2.调整堆结构+交换堆顶元素与末尾元素
        for (int j = arr.length - 1; j > 0; j--) {
            swap(arr, 0, j);//将堆顶元素与末尾元素进行交换
            adjustHeap(arr, 0, j);//重新对堆进行调整
        }

    }

    public static void adjustHeap(int[] arr, int i, int length) {
        int temp = arr[i];//先取出当前元素i
        //一个节点i的左子节点为(i*2 + 1)，右子节点为(i*2 + 2)
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            //先找到左右子节点最大的元素（大顶堆就找最大的元素，小顶堆就找最小的元素）
            //从i结点的左子结点开始，也就是2i+1处开始
            if (k + 1 < length && arr[k] < arr[k + 1]) {//如果左子结点小于右子结点，k指向右子结点
                k++;
            }
            
            //再用子节点中最大的元素和父节点对比大小
            if (arr[k] > temp) {
                //如果子节点大于父节点，将子节点和父节点交换
                swap(arr, i, k);
                i = k;
            } else {
                break;
            }
        }
    }

    /**
     * 交换元素
     */
    public static void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```

以上思想可归纳为两个操作：

1. 根据初始数组去**构造初始堆**（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。

2. 每次**交换第一个和最后一个元素，输出最后一个元素**（最大值），然后把剩下元素**重新调整**为大顶堆。 

先通过详细的实例图来看一下，如何构建初始堆。

设有一个无序序列 { 1, 3, 4, 5, 2, 6, 9, 7, 8, 0 }。

![img](https://gitee.com/syllr/images/raw/master/uPic/20210916143829GepjkB.png)

1. 首先找到第一个非叶子结点length / 2 - 1，也就是节点2，判断节点2的叶子结点中最大的元素和2的大小
2. 节点2只有一个节点0，2比0大，所以不交换2和0的位置
3. **此时如果节点2还有子节点，还应该继续对2节点中最大的子节点继续进行判断，判断该子节点和它的子节点的大小，代码第34行**
4. 继续对非叶子结点进行判断，判断节点5，节点5的叶子结点有7和8
5. 节点8比7大，所以用右子节点8和5做对比，8比5大，所以把8和5节点进行交换，同时继续判断交换位置之后8节点的子节点和8节点是否构成了大顶堆这是一个循环的过程
6. 重复上面的过程至道最后一个非叶子结点被判断完

## 排序算法总结

![image-20200722153422804](https://gitee.com/syllr/images/raw/master/uPic/20210916105300yHv8Mg.jpg)

# 数组

## 二分查找

二分查找的时候最重要的几个点

* while循环的跳出规则

  > while循环最容易产生出两种情况
  >
  > * 死循环
  > * 漏掉left=right相等的情况
  >
  > 这里做一下总结，while循环的判断条件有两种while(left <= right)，和while(left<right)，具体采用那种由二分法分出来的区间来判断，区间[left, right]有三种分法
  >
  > 1. 分成[left, mid - 1]，[mid, mid]，[mid + 1, right]
  > 2. 分成[left, mid]，[mid + 1, right]
  > 3. 分成[left, mid - 1]，[mid, right]
  >
  > 第一种分法采用while(left <= right)
  >
  > 剩下两种采用while(left < right)

* 下一轮搜索区间的判断

  > 下一轮搜索区间一定要分三种情况来讨论，即target=mid,target>mid,target<mid，可以分开分析三种情况然后再合并，这样思考的过程更清晰

* mid的计算最好用`mid = left  + (right - left) / 2`，如果直接用`mid = (left + right) / 2`，可能会有数值溢出的问题

  > mid的计算有两种情况
  >
  > * mid = left + (right - left) / 2;在区间是[left, mid - 1]，[mid, mid]，[mid + 1, right]，或者[left, mid - 1]，[mid, right]这种情况采用这种算法
  > * mid = left + (right - left + 1) / 2;当区间为[left, mid]，[mid + 1, right]，要在计算mid中间加一，不然会有死循环

![image-20200717143727888](https://gitee.com/syllr/images/raw/master/uPic/20210912165204N7CNl0.jpg)

### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```java
class Solution {
    public int search(int[] nums, int target) {
        //定义左边界和右边界
        int left = 0;
        int right = nums.length - 1;
        //二分法使用循环
        while (left <= right) {
          	int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else {
                if (nums[mid] > target) {
                    //在左边
                    right = mid - 1;
                } else {
                    //在右边
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
}
```

### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/submissions/)

分析：这道题要求我们在一个有序数组里查找插入元素的位置，那么什么是插入元素的位置呢？我们看示例。

* 示例 1：目标元素 55 在有序数组 [1,3,5,6] 里，下标为 22，输出 22；
* 示例 2：目标元素 22 不在有序数组 [1,3,5,6] 里，返回 33 的下标 11 ，我们可以知道，如果数组中不存在目标元素，返回第 1 个严格大于目标元素的数值的下标；
* 示例 3：目标元素 77 不在有序数组 [1,3,5,6] 里。特别地，77 比最后一个元素 66 还大，返回最后一个元素的下标 +1+1；
* 示例 4：目标元素 00 不在有序数组 [1,3,5,6] 里。特别地，00 比第一个元素 11 还小，返回第 1 个元素的下标 00。

由上面 4 个示例，知道题目要我们找的是 大于等于目标元素的第 11 个下标。

```java
public class Solution {
    /**
     * 查找大于等于目标元素的第一个下标
     */
    public int searchInsert(int[] nums, int target) {
        int length = nums.length;
        //特判
        if (length == 0) {
            return 0;
        }
        if (nums[length - 1] < target) {
            return length;
        }
        //设置左右
        int left = 0;
        int right = length - 1;
	      //因为在选取下一轮搜索区间时，right=mid - 1; left = mid + 1;都是有前进或者后退的，所以while循环里面的条件一定是left <= right
	      //不然当left加一，或者right减一之后，刚好left==right，如果while(left < right)，就会漏掉这种情况
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (target == nums[mid]) {
                return mid;
            }
            if (target < nums[mid]) {
                //下一轮搜索区间[left, mid - 1]
                right = mid - 1;
            } else {
                //下一轮搜索区间[mid, right]
                left = mid + 1;
            }
        }
      	//最后判断能否在数组中查找到target，如果没有找到，则直接返回第一个大于目标元素的下标
        if (target > nums[left]) {
            return left + 1;
        }
        return left;
    }
}
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

* 第一种先通过二分查找任意一个target的下标，然后向前向后遍历，再找到元素的第一个和最后一个位置

  ```java
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          //先用二分查找随便查找任意一个target所在的下标，如果返回-1，说明target没有在nums数组中，直接返回[-1, -1]
          int index = binarySearch(nums, target);
          if (index < 0) {
              return new int[]{-1, -1};
          }
  
          int[] result = new int[2];
          int leftIdx = index;
          int rightIdx = index;
          //任意找到一个target的下标之后，向前遍历，找到元素的第一个位置，注意数组下标的不要越界
          while (leftIdx > 0 && target == nums[leftIdx]) {
              if (target == nums[leftIdx - 1]) {
                  leftIdx--;
              } else {
                  break;
              }
          }
          //向后遍历找到元素的最后一个位置，注意数组下标不要越界
          while (rightIdx < nums.length - 1 && target == nums[rightIdx]) {
              if (target == nums[rightIdx + 1]) {
                  rightIdx++;
              } else {
                  break;
              }
          }
          result[0] = leftIdx;
          result[1] = rightIdx;
          return result;
      }
  
      int binarySearch(int[] nums, int target) {
          if (nums.length == 0) {
              return -1;
          }
  
          int left = 0;
          int right = nums.length - 1;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              if (nums[mid] == target) {
                  return mid;
              }
              if (target > nums[mid]) {
                  left = mid + 1;
              } else {
                  right = mid - 1;
              }
          }
          return -1;
      }
  }
  ```

* 分别通过二分查找法分别找到第一个元素和最后一个元素的位置

  ```java
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          if (nums.length == 0) {
              return new int[]{-1, -1};
          }
          int firstIndex = searchFirst(nums, target);
          if (firstIndex < 0) {
              return new int[]{-1, -1};
          }
          int lastIndex = searchLast(nums, target);
          return new int[]{firstIndex, lastIndex};
      }
  
      /**
       * 找到第一个元素的位置
       */
      int searchFirst(int[] nums, int target) {
          int left = 0;
          int right = nums.length - 1;
          while (left <= right) {
              if (left == right && nums[left] == target) {
                  return left;
              }
              int mid = left + (right - left) / 2;
              /*
                分为三种情况,
                如果刚好target==mid，而我们需要找的是第一个元素，现在mid可能是第一个也可能是比第一个大的元素
                所以下一次需要查找的区间，应该包含mid，而区间整体向左
               */
              if (nums[mid] == target) {
                  //因为right=mid，同时while(left <= right)，在这种情况下会会出现死循环，所以要在第21行添加判断，跳出死循环
                  right = mid;
              }
  
              /*
              如果target > mid，那么第一个元素所在的位置也是大于mid
               */
              if (nums[mid] < target) {
                  left = mid + 1;
              }
  
              if (nums[mid] > target) {
                  right = mid - 1;
              }
  
          }
          return -1;
      }
  
      /**
       * 找到最后一个元素的位置
       */
      int searchLast(int[] nums, int target) {
          int left = 0;
          int right = nums.length - 1;
          while (left <= right) {
              if (left == right && nums[right] == target) {
                  return right;
              }
              int mid = left + (right - left + 1) / 2;
              if (nums[mid] == target) {
                  //因为left=mid，同时while(left <= right)，在这种情况下会会出现死循环，所以要在第57行添加判断，跳出死循环
                  left = mid;
              }
  
              if (nums[mid] > target) {
                  right = mid - 1;
              }
  
              if (nums[mid] < target) {
                  left = mid + 1;
              }
          }
          return -1;
      }
  }
  ```

### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {

            int mid = left + (right - left) / 2;
            //分为三种情况判断，如果mid==right说明只有一个元素了，一定是最小的，直接返回
            if (mid == right) {
                return nums[mid];
            }

            //如果nums[mid] > nums[right]，说明最小的元素一定在(mid, right]之间
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                //因为我们要找的就是最小的元素，nums[mid] < nums[right]，最小的元素可能就是mid，下一次搜索区间应该为[left, mid]
                right = mid;
            }
        }
        return nums[left];
    }
}
```

### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        //搜索区间可以分为两种类型
        // 一种是left < right，这种可以称之为单调区间
        //另一种是left > right，这种区间里面分为两部分，两部分分别都是单调的，可以称之为部分单调区间
        //首先第一步就是判断搜索区间是属于那种区间，因为不一样的区间有不一样的搜索方式，这里要使用到递归
        return doSearch(nums, target, left, right);
    }

    private int doSearch(int[] nums, int target, int left, int right) {
        if (left == right) {
            if (nums[left] == target) {
                return left;
            } else {
                return -1;
            }
        }
        //判断搜索区间是属于单调区间还是部分单调区间
        if (nums[left] > nums[right]) {
            //部分单调区间
            //利用二分把部分单调区间分割成两个区间，其中一个是单调区间，另一个是部分单调区间，并且判断target在那个区间中
            int mid = left + (right - left) / 2;
            //确定左右两个区间哪一个是单调区间
            if (nums[left] < nums[mid]) {
                //[left, mid]是单调区间
                //判断target是否在单调区间内，如果不在单调区间那么肯定在部分单调区间
                if (nums[left] <= target && nums[mid] >= target) {
                    //在单调区间内，就用二分法直接查找
                    return binSearch(nums, target, left, mid);
                } else {
                    //不在单调区间内就在部分单调区间，继续递归
                    return doSearch(nums, target, mid + 1, right);
                }
            } else {
                //[mid + 1, right]是单调区间
                //判断target是否在单调区间内，如果不在单调区间那么肯定在部分单调区间
                if (nums[mid + 1] <= target && nums[right] >= target) {
                    //在单调区间内，就用二分法直接查找
                    return binSearch(nums, target, mid + 1, right);
                } else {
                    return doSearch(nums, target, left, mid);
                }
            }
        } else {
            //单调区间，直接使用二分查找法查找
            return binSearch(nums, target, left, right);
        }
    }


    private int binSearch(int[] nums, int target, int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            }

            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

### [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        if (arr.length == 1) {
            return arr[0];
        }
        int left = 1;
        int right = arr.length - 2;
        //区间分为两种，一种是单调区间，一种是部分单调区间，最大值肯定在部分单调区间中，所以第一件事就是确定部分单调区间
        while (left < right) {

            //以为后面有left = mid，在计算mid的时候会陷入死循环，所以一定要+1，避免死循环
            int mid = left + (right - left + 1) / 2;
            if (arr[mid] > arr[mid - 1]) {
                //如果mid在单调区间中，mid有可能是峰顶，所以mid不能丢弃，下一个搜索区间为[mid, right]
                left = mid;
            } else {
                //下一个搜索区间为[left, mid - 1]
                right = mid - 1;
            }
        }
        return left;
    }
}
```

### [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

分析：这道问题要求我们计算一个非负整数的平方根，返回值是一个整数。示例 1 是好理解的，由示例 2 我们知道，当平方根是浮点数的时候，我们需要下取整。

这是一道使用二分查找算法解决的典型问题。首先我们思考暴力解法，以加深对这个问题的理解。

方法一：暴力解法
我们看示例 2 ，输入 8 返回的是 2，这是因为 3 的平方等于 9 大于 8，因此「结果只保留整数的部分，小数部分将被舍去」。要求我们从 1 开始找，找到最后一个平方以后小于等于 x 的那个数。

我们假设 s 表示从 1 开始的那个数。

* 如果 s 平方以后小于 x ，暂时放过；

* 如果 s 平方以后等于 x ，直接返回 s ；

* 如果 s 平方以后大于 x ，说明 s - 1 是题目要求的，返回 s - 1 。

  > 友情提示：不要忽视对暴力解法的思考，在面试和笔试中可以不实现暴力解法，但是对暴力解法的缺点和潜在的问题需要有一定的分析，过渡到优化解法会更自然。

参考代码 1：

```java
class Solution {
    public int mySqrt(int x) {
        //暴力解法，通过遍历，找到最后一个满足条件的数
        int result = 1;
        int num = 0;
        while (true) {
            //注意不要用乘法，因为可能会类型溢出
            num = x / result;
            if (num < result) {
                break;
            } else {
                result++;
            }
        }
        return --result;
    }
}
```

通过对暴力解法的分析，我们知道了，需要返回最后一个平方以后小于等于 x 的数。使用二分查找的思路 2，关键在于分析那些数是我们不要的。

很容易知道，如果一个数的平方大于 x ，这个数就一定不是我们要找的平方根。于是，可以通过逼近的方式找到平方根。

```java
class Solution {
    public int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        //二分法首先确定数据的查找范围
        int left = 1;
        int right = x / 2;
        while (left <= right) {
            int mid = left + (right - left + 1) / 2;
            if (mid == left) {
                return mid;
            }

            int division = x / mid;

            if (division == mid) {
                return mid;
            }
            if (division > mid) {
                //下一次的搜索区间为[mid, right]
                left = mid;
            } else {
                //下一次的搜索区间为[left, mid - 1]
                right = mid - 1;
            }
        }
        return left;
    }
}
```

### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

```java
class Solution {
    public int findDuplicate(int[] nums) {
        //二分法明确查找范围
        int left = 0;
        int right = nums.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            int midCnt = 0;
            //判断整个数组中小于等于mid的元素个数，如果和mid不一样，说明重复元素的区间就在[0, mid]中
            for (int num : nums) {
                if (num <= mid) {
                    midCnt++;
                }
            }

//            if (midCnt == mid) {
//                left = mid + 1;
//            }

            if (midCnt > mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

### [1300. 转变数组后最接近目标值的数组和](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/)

```java
class Solution {
    public int findBestValue(int[] arr, int target) {
        //首先找到二分法的搜索范围，就要先找到数组中最大的元素值和最小的数值
        int left = 0;
        int right = 0;
        for (int num : arr) {
            right = Math.max(right, num);
            left = Math.min(left, num);
        }
        while (left < right) {
            int mid = left + (right - left + 1) / 2;
            //所谓最接近target无非就是当sum刚好大于target或者刚好小于target的时候二者取其一，所以首先是要找到sum刚好低于target的第一个value或则刚好大于target的第一个value
            //这里我们选择刚好低于target的第一个value
            //进行区间的划分
            //区间划分的条件，数组中所有大于mid的数都变成mid之后的sum
            int sum = sum(arr, mid);
            if (sum == target) {
                return mid;
            }

            if (sum < target) {
                //下一个搜索区间是[mid, right]
                left = mid;
            }else {
                //下一个搜索区间是[left, mid - 1]
                right = mid - 1;
            }
        }
        //最后判断left和left+1哪个和target的差值更小
        int sum = sum(arr, left);
        int otherSum = sum(arr, left + 1);
        if (Math.abs(otherSum - target) >= Math.abs(sum - target)) {
            return left;
        } else {
            return left + 1;
        }
    }

    private int sum(int[] arr, int value) {
        int sum = 0;
        for (int num : arr) {
            if (value >= num) {
                sum = sum + num;
            } else {
                sum = sum + value;
            }
        }
        return sum;
    }
}
```

### [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        //二分首先判断搜索区间的范围，每小时至少吃一根，所以left应该是1，最多吃数组中最大的元素，吃多了也没有意义
        int left = 1;
        int right = 0;
        for (int pile : piles) {
            right = Math.max(right, pile);
        }
        while (left < right) {
            int mid = left + (right - left) / 2;
            //判断下一次搜索区间的范围
            //判断每小时吃mid根的时候花费的时间是否大于H小时，如果是，则下一次的搜索区间一定在[mid + 1, right];否在搜索区间为[left, mid]
            int hours = eat(piles, mid);
            if (hours > h) {
                //下一次的搜索区间为[mid + 1, right];
                left = mid + 1;
            } else {
                //下一次的搜索区间为[left, mid];
                right = mid;
            }
        }
        return left;
    }

    /**
     * 在每小时吃value根的时候吃完所有的香蕉要多少个小时
     *
     * @return 吃完所有香蕉要的小时数
     */
    private int eat(int[] piles, int value) {
        int allHours = 0;
        for (int pile : piles) {
            int hour = pile / value;
            int remain = pile % value;
            if (remain > 0) {
                allHours = allHours + hour + 1;
            } else {
                allHours = allHours + hour;
            }
        }
        return allHours;
    }
}
```

### [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        //二分搜索首先确定搜索的范围区间
        int left = weights[0];
        int right = 0;
        for (int weight : weights) {
            left = Math.max(left, weight);
            right = right + weight;
        }
        while (left < right) {
            int mid = left + (right - left) / 2;
            //判断下一次的搜索区间
            //因为在搜索范围中，承重越多，所需要的天数越少，所以如果每天运送mid，需要的天数spendDays大于days，说明mid小于最佳重量，不满足要求，下一次的搜索区间为[mid + 1, right];
            //反之下一次的搜索区间为[left, mid];
            int spendDays = spendDays(weights, mid);
//            if (spendDays == days) {
//                //下一个搜索区间为[left, mid]
//                right = mid;
//            }

            if (spendDays > days) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }

    /**
     * 计算需要的天数
     */
    private int spendDays(int[] weights, int value) {
        int spendDays = 0;

        for (int index = 0; index < weights.length; ) {
            int remainWeight = value;
            while (index < weights.length && remainWeight >= weights[index]) {
                remainWeight = remainWeight - weights[index];
                index++;
            }
            spendDays = spendDays + 1;
        }
        return spendDays;
    }
}
```

## 数组里另外常见的两类算法

![image-20200723124524603](https://gitee.com/syllr/images/raw/master/uPic/20210916145036mB9A3l.jpg)

滑动窗口」问题也可以理解为是一种特殊的「双指针」的问题。它们都使用了两个变量，在完成 数组 中的相关任务中发挥了作用。

它们的区别在于两个变量的移动方式不同：

* 应用「滑动窗口」的问题，两个变量同向移动；
* 应用「双指针」的问题，两个变量一头一尾，向着中间移动。「二分查找」就是一种特殊的应用「双指针」解决的问题。

### 滑动窗口

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

##### 暴力解法

- 枚举这个字符串的所有子串；
- 对于每一个子串都判断一下这个子串是否有重复字符；
- 在从没有重复字符的所有子串中找出长度最长的那个，返回即可。

暴力解法中有相同前缀的所有字串都会被检查一次，造成了大量的浪费，滑动窗口通过移动区间的左边界，来一次性排出所有相同前缀的子串

##### 滑动窗口解法

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        //寻找无重复的最长子串
        //滑动窗口
        int left = 0;
        //用来记录每个字符出现的频率
        int[] freq = new int[128];
        int length = 0;
        //循环不变量：[left, right]区间里面没有重复元素，子串长度length = right - left + 1
        //right主动移动，每次循环都移动一次，left被动移动（就是当发现[left, right]里面有重复的字符left才移动）
        char[] chars = s.toCharArray();
        for (int right = 0; right < chars.length; right++) {
            freq[chars[right]]++;
            if (freq[chars[right]] == 2) {
                //说明该字符重复出现，left要左移，一直移动到上一个ch出现的位置的下一个字符
                while (chars[left] != chars[right]) {
                    freq[chars[left]]--;
                    left++;
                }
                left++;
                freq[chars[right]]--;
            }
            length = Math.max(length, right - left + 1);
        }
        return length;
    }
}
```

#### 滑动窗口算法经典框架

```java
public class Solution {

    public String minWindow(String s, String t) {
        // 同方向移动，起始的时候，都位于 0，表示我们定义搜索区间为 [left, right) ，此时区间为空区间
        int left = 0;
        int right = 0;

        while (right < sLen) {

            if ( 在右移的过程中检测是否满足条件 ) {
                // 对状态做修改，好让程序在后面检测到满足条件
            }

            // 右边界右移 1 格
            right++;

            while ( 满足条件 ) {

                // ① 走到这里是满足条件的，左边界逐渐逐渐左移，可以取最小值

                if ( 在左移的过程中检测是否不满足条件 ) {
                    // 对状态做修改，好让程序在后面检测到不满足条件
                }

                // 左边界左移 1 格
                left++;
            }
            // ② 走到这里是不满足条件的，右边界逐渐右移，可以取最大值
        }
        return 需要的结果变量;
    }
}
```

#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //循环不变量：[left, right]中所有元素的和大于等于target
        //left,right都是被动移动
        int sum = 0;
        int length = Integer.MAX_VALUE;
        for (int left = 0, right = 0; right < nums.length; right++) {
            sum = sum + nums[right];
            if (sum >= target) {
                //left要一直右移，直到sum<target
                while (sum >= target) {
                    sum = sum - nums[left];
                    left++;
                }
                //[left, right]区间的长度是right - left + 1，但是因为在while循环结束前left++了，所以计算长度的时候要再+1。
                length = Math.min(length, right - left + 2);
            }
        }
        if (length == Integer.MAX_VALUE) {
            return 0;
        }
        return length;
    }
}
```

### 双指针

双指针经典题就是求和问题，两数之和，三数之和，四数之和

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

##### 哈希表解法

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        //两数之和 哈希表解法
        Map map = new HashMap();
        for (int index = 0; index < nums.length; index++) {
            int remain = target - nums[index];
            if (map.get(remain) != null) {
                return new int[]{(int) map.get(remain), index};
            }
            map.put(nums[index], index);
        }
        return null;
    }
}
```

##### 双指针解法（暴力循环）

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        //两数之和 双指针
        if (nums.length < 2) {
            return null;
        }

        //先确定一个元素的位置，然后再在剩下的元素里面找到和为target的元素
        for (int index = 0; index < nums.length; index++) {
            for (int innerIndex = index + 1; innerIndex < nums.length; innerIndex++) {
                if (nums[innerIndex] + nums[index] == target) {
                    return new int[]{index, innerIndex};
                }
            }
        }
        return null;
    }
}
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

如果我们将上个题目得指针解法称做是双指针的话，那么这个题目用到的方法就是三指针，因为我们是三数之和嘛，一个指针对应一个数，下面我们看一下具体思路，其实原理很简单，我们先将数组排序，直接 Arrays.sort() 解决，排序之后处理起来就很容易了。下面我们来看下三个指针的初始位置。

![三数之和起始](https://gitee.com/syllr/images/raw/master/uPic/202109170037185H5dmr.png)

初始情况见上图，我们看当前情况，三数之和为 -3 ，很显然不是 0 ，那么我们应该怎么做呢？

我们设想一下，我们当前的三数之和为 -3 < 0 那么我们如果移动橙色指针的话则会让我们的三数之和变的更小，因为我们的数组是有序的，所以我们移动橙色指针（蓝色不动）时和会变小，如果移动蓝色指针（橙色不动）的话，三数之和则会变大，所以这种情况则需要向右移动我们的蓝色指针，找到三数之和等于 0 的情况进行保存，如果三数之和大于 0 的话，则需要移动橙色指针，途中有三数之和为 0 的情况则保存。直至蓝橙两指针相遇跳出该次循环，然后我们的绿指针右移一步，继续执行上诉步骤。但是这里我们需要注意的一个细节就是，我们需要去除相同三元组的情况，我们看下面的例子。

![三数之和举例](https://gitee.com/syllr/images/raw/master/uPic/20210917003727CeZnd0.png)

这里我们发现 0 - 1 + 1 = 0，当前情况是符合的，所以我们需要存入该三元组，存入后，蓝色指针向后移动一步，橙色指针向前移动一步，我们发现仍为 0 -1 + 1 = 0 仍然符合，但是如果继续存入该三元组的话则不符合题意，所以我们需要去重。这里可以借助HashSet但是效率太差，不推荐。这里我们可以使用 while 循环将蓝色指针移动到不和刚才相同的位置，也就是直接移动到元素 0 上，橙色指针同样也是。则是下面这种情况，这样我们就实现了去重，然后继续判断当前三数之和是否为 0 。

![三数之和例子](https://gitee.com/syllr/images/raw/master/uPic/20210917003735OMYhLh.png)

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();

        if (nums.length < 3) {
            return result;
        }
        //先将数组排序
        Arrays.sort(nums);
        for (int index = 0; index < nums.length - 2; index++) {
            int target = -nums[index];
            int left = index + 1;
            int right = nums.length - 1;
            while (left < right) {
                int sum = nums[left] + nums[right];
                if (sum == target) {
                    List<Integer> resultEle = new ArrayList<>();
                    resultEle.add(nums[index]);
                    resultEle.add(nums[left]);
                    resultEle.add(nums[right]);
                    result.add(resultEle);
                    //这里要排除所有重复结果，因为已经排序了，所以直接跳过相同的元素

                    //left跳过相同元素
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    left++;

                    //right跳过相同的元素
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    right--;

                    //index也要跳过相同的元素
                    while (index < nums.length - 2 && nums[index] == nums[index + 1]) {
                        index++;
                    }

                } else if (sum > target) {
                    right--;
                } else {
                    left++;
                }
            }
        }

        return result;
    }
}
```

#### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        //数组排序
        Arrays.sort(nums);
        //四数之和
        //先选择一个数，就变成了三数之和
        for (int index = 0; index < nums.length - 3; index++) {
            //后面就是三数之和
            for (int innerIndex = index + 1; innerIndex < nums.length - 2; innerIndex++) {
                int left = innerIndex + 1;
                int right = nums.length - 1;
                int sum = target - nums[index] - nums[innerIndex];
                while (left < right) {
                    if (nums[left] + nums[right] == sum) {
                        List<Integer> resultEle = new ArrayList<>();
                        resultEle.add(nums[index]);
                        resultEle.add(nums[innerIndex]);
                        resultEle.add(nums[left]);
                        resultEle.add(nums[right]);
                        result.add(resultEle);

                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }

                        left++;

                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }

                        right--;

                        while (index < nums.length - 3 && nums[index] == nums[index + 1]) {
                            index++;
                        }

                        while (innerIndex < nums.length - 2 && nums[innerIndex] == nums[innerIndex + 1]) {
                            innerIndex++;
                        }
                    } else if (nums[left] + nums[right] > sum) {
                        right--;
                    } else {
                        left++;
                    }
                }
            }
        }
        return result;
    }
}
```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        //双指针
        int left = 0;
        int right = height.length - 1;
        int area = 0;

        while (left < right) {
            area = Math.max(area, (right - left) * Math.min(height[left], height[right]));
            
            //比较面积大小
            //比较height[left]和height[right]的大小，小的移动
            if (height[left] > height[right]) {
                right--;
            } else {
                left++;
            }
        }
        
        return area;
    }
}
```

# 链表

链表和数组的区别在于数组可以通过偏移量支持随机访问，而链表的数据分散在内存的不同位置，通常由CPU随机分配，

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210917151538uICaqZ.png)

## 链表分类

### 双向链表

「双向链表」是指一个 线性结构 的每个数据以结点的方式存储，并且每一个结点出了必要的真正存放数据的区域以外 只 含有两个存放其它结点的数据块。这两个数据块分别存储了当前结点的上一个结点（前驱结点）的内存地址和下一个结点（后继结点）的内存地址。

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210917152506XkMsZJ.png)

双向链表的第一个结点没有前驱结点，最后一个结点没有后继结点。

单向链表只能从第一个结点开始按照顺序单向访问链表中的结点，每一个结点只能访问到它的后继结点，而双向链表有两个指针变量，每一个结点除了能访问到它的后继结点以外，还以访问到前驱结点。

双向链表可以应用于 LRU 缓存机制

### 循环链表

如果「单向链表」的最后一个结点指向「单向链表」的第一个结点，在逻辑上就形成了一个环形结构，这样的链表就称为「循环单向链表」。「循环单向链表」的一个经典应用是模拟约瑟夫环问题，感兴趣的朋友可以在互联网上进行搜索，我们在这里就不多做介绍了。

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210917152530BSUXm1.png)

如果「双向链表」的第一个结点的前驱结点指向链表的最后一个结点，最后一个结点后继结点指向链表的第一个结点，在逻辑上也形成了一个环形结构，这样的链表就称为「循环双向链表」。

![image.png](https://gitee.com/syllr/images/raw/master/uPic/20210917152550nFlEka.png)



### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

循环解法

* 定义两个指针： prepre 和 curcur ；prepre 在前 curcur 在后。
* 每次让 prepre 的 nextnext 指向 curcur ，实现一次局部反转
* 局部反转完成之后，prepre 和 curcur 同时往前移动一个位置
* 循环上述过程，直至 prepre 到达链表尾部

![img](https://gitee.com/syllr/images/raw/master/uPic/20210917154640Wdn3Xn.gif)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode current = head;
        ListNode pre = null;

        while (current != null) {
            //1<-2<-3 4->5
            //这个时候currentNode是4，pre是3
            //循环要继续下去，下一个currentNode应该是5，同时要用一个变量保存当前的current，要将current的next设置为pre
            ListNode tmp = current;
            current = current.next;
            tmp.next = pre;
            //现在链表变成了
            //1<-2<-3<-4 5
            //pre应该变成4
            pre = tmp;
        }

        //循环结束链表变成1<-2<-3<-4<-5
        //current为null，pre为5
        return pre;
    }


    public class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

简洁的递归

* 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 retret .
* 此后，每次函数在返回的过程中，让当前结点的下一个结点的 nextnext 指针指向当前节点。
* 同时让当前结点的 nextnext 指针指向 NULLNULL ，从而实现从链表尾部开始的局部反转
* 当递归函数全部出栈后，链表反转完成。

![img](https://gitee.com/syllr/images/raw/master/uPic/20210917225844mbL3xB.gif)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        //递归求解

        //求解问题：直到最后一个节点没有子节点，把这个节点单独看作一个链表的开头，可以看出这个链表就是反转后的链表，可以直接返回
        if (head == null || head.next == null) {
            return head;
        }
        //分解问题，当当前节点还有子节点时递归
        ListNode last = head.next;
        ListNode reverseHead = reverseList(last);
        //合并问题：假设递归返回的链表是已经反序的，那么递归中当前head节点的下一个节点head.next就是已经反序链表的最后一个，ListNode last = head.next
        //把反序链表的最后一个元素的next设置为当前head：last.next = head;
        last.next = head;
        //因为原来的head.next是不为空的，倒序之后要手动设置为空，防止循环引用，last.next此时应该表示反序链表的最后一个节点，这个节点的next应该为空
        last.next.next = null;

        return reverseHead;
    }


    public static class ListNode {

        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }


        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

头插法

1. 我们定义两个指针，分别称之为 g(guard 守卫) 和 p(point)，

   > 新建一个dummyHead
   >
   > ListNode dummyHead = new ListNode();
   >
   > dummyHead.next = head;
   >
   > ListNode guard = dummyHead;
   >
   > ListNode point = head;

2. 将 p 后面的元素删除，然后添加到 g 的后面。也即头插法

3. 根据 m 和 n 重复步骤（2）

4. 返回 dummyHead.next

![img1.png](https://gitee.com/syllr/images/raw/master/uPic/20210918100647wFLL1d.png)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode dummyHead = new ListNode();
        dummyHead.next = head;
        ListNode guard = dummyHead;
        ListNode point = head;
        //1(g)->2(p)->3->4->5
        //头插法，把point后面的元素remove掉，放在g的后面
        while (point != null && point.next != null) {
            //把p后面的元素和链表本身脱离
            ListNode removed = point.next;
            point.next = point.next.next;

            //再把remove元素插入guard的后面
            removed.next = guard.next;
            guard.next = removed;
        }

        return dummyHead.next;
    }


    public class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```



### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        //left和right是元素的个数 不是索引下标，所以从1开始
        if (left == right) {
            return head;
        }
        ListNode pre = null;
        ListNode begin = head;
        if (left > 1) {
            for (int i = 2; i <= left; i++) {
                pre = begin;
                begin = begin.next;
            }
        }

        //循环反转[left, right]区间中的元素
        //pre -> [left, right] -> next to pre -> [right, left] -> next
        ListNode reversePre = null;
        ListNode reverseCurrent = begin;
        //1<-2<-3 4->5，假设这时reverseCurrent = 4，reversePre = 3
        //1<-2<-3<-4 5，要变成reverseCurrent = 5, reversePre = 4
        int index = left;
        while (reverseCurrent != null && index <= right) {
            ListNode tmp = reverseCurrent;
            reverseCurrent = reverseCurrent.next;
            tmp.next = reversePre;
            //这里reverseCurrent已经变了，所以要引入中间变量保存
            reversePre = tmp;
            index++;
        }
        //循环结束1<-2<-3<-4<-5 reverserCurrent = right.next, reversePre = 5
        begin.next = reverseCurrent;
        //有一种特殊情况：当left=1的时候要特殊处理
        if (pre != null) {
            pre.next = reversePre;
            return head;
        } else {
            return reversePre;
        }
    }


    public static class ListNode {

        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }


        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

头插法

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        int index = 1;
        ListNode dummyHead = new ListNode();
        dummyHead.next = head;
        //头插法
        ListNode guard = dummyHead;
        ListNode point = dummyHead.next;

        //找到开始反序的节点
        while (index < left) {
            guard = guard.next;
            point = point.next;
            index++;
        }
        while (point != null && point.next != null && index < right) {
            //把point后面的节点移除
            ListNode remove = point.next;
            point.next = point.next.next;

            //把remove插入到guard后面
            remove.next = guard.next;
            guard.next = remove;
            index++;
        }

        return dummyHead.next;
    }


    public static class ListNode {

        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }


        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        //使用递归
        //根据题目的要求，递归函数的功能是返回已经反序的链表头
        //分解：如果链表的next!=null就行了递归
        //求解：当链表中只有一个元素，就已经是反序，直接返回
        //合并：判断当前的节点是奇节点还是偶节点，如果是奇节点要和下级递归函数返回的头节点进行反转，如果是偶节点直接将下级递归函数返回的头节点设置为next（其实就是不用做处理）

        //设置dummyHead
        ListNode dummyHead = new ListNode();
        dummyHead.next = head;
        return swapPairs(dummyHead, dummyHead.next, 1);
    }

    /**
     * @param head  当前链表头节点
     * @param index 当前链表头节点在整个链表的顺序（可以用来判断奇偶）
     */
    private ListNode swapPairs(ListNode pre, ListNode head, int index) {
        //求解
        if (head == null || head.next == null) {
            return head;
        }

        //分解
        ListNode next = swapPairs(head, head.next, index + 1);

        //合并
        if (index % 2 == 0) {
            //如果当前节点是偶
            head.next = next;
        } else {
            //如果当前节点是奇，需要反转
            //删除next
            head.next = next.next;
            //把next插入pre后面
            pre.next = next;
            next.next = head;
        }

        return pre.next;
    }

    public static class ListNode {

        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }

        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //从头到尾遍历一遍 对比元素大小
        ListNode dummyHead = new ListNode();
        dummyHead.next = head;
        ListNode current = dummyHead.next;
        ListNode pre = dummyHead;
        while (current != null) {
            if (current.val == val) {
                //要删除这个节点
                pre.next = current.next;
                current = current.next;
            } else {
                //不用删除这个节点
                pre = pre.next;
                current = current.next;
            }
        }

        return dummyHead.next;
    }

    public static class ListNode {

        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }

        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

### [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        //需要维护四个变量，奇数的头，奇数的尾，偶数的头，偶数的尾
        //分别维护奇链表和偶链表，等循环结束再把两个链表合并
        ListNode oddHead = null;
        //奇数的尾
        ListNode oddTail = null;
        //偶数的头
        ListNode evenHead = null;
        //偶数的尾
        ListNode evenTail = null;

        ListNode currentNode = head;

        int index = 1;
        while (currentNode != null) {
            if (index % 2 == 0) {
                if (evenHead == null) {
                    evenHead = currentNode;
                    evenTail = currentNode;
                } else {
                    evenTail.next = currentNode;
                    evenTail = evenTail.next;
                }
            } else {
                //奇数应该插入到奇数尾巴的后面
                if (oddHead == null) {
                    oddHead = currentNode;
                    oddTail = currentNode;
                } else {
                    oddTail.next = currentNode;
                    oddTail = oddTail.next;
                }
            }
            currentNode = currentNode.next;
            index++;
        }
        //要修改偶尾的next节点，不然会出现循环引用
        if (evenTail != null) {
            evenTail.next = null;
        }

        //当奇偶链表都确定之后，再把奇偶链表合并起来
        if (oddTail != null) {
            oddTail.next = evenHead;
        }
        return oddHead;
    }

    public static class ListNode {

        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }

        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

## 虚拟头节点（dummyHead）

链表的问题最容易出现头节点的边界问题，可以使用一个虚拟头节点来避免边界问题的讨论，一般的套路是

```java
ListNode dummyHead = new ListNode();
//把头节点设置为dummyHead的后序，这样可以避免头节点为空的问题
dummyHdea.next = head;
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //首先确定链表长度
        ListNode current = head;
        int length = 0;
        while (current != null) {
            //只要current不为null 长度就是1
            current = current.next;
            length++;
        }

        //要删除倒数第N个元素，就是删除正数第length - N + 1个元素
        //要删除正数第length - N + 1个元素，就要找到第length - N个元素
        ListNode dummyHead = new ListNode();
        dummyHead.next = head;
        ListNode currentNode = dummyHead;
        //走length - n步，第一步就是head
        for (int index = 0; index < length - n; index++) {
            currentNode = currentNode.next;
        }
        //循环过后currentNode就是第length - N个元素
        if (currentNode.next != null) {
            currentNode.next = currentNode.next.next;
        }
        return dummyHead.next;
    }

    public static class ListNode {
        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }

        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //设置虚拟头节点
        ListNode dummyHead = new ListNode();
        ListNode pre = dummyHead;
        //进位标志
        int flag = 0;
        while (l1 != null || l2 != null) {
            int l1val = 0;
            int l2val = 0;
            ListNode currentNode = new ListNode();
            if (l1 != null) {
                l1val = l1.val;
            }
            if (l2 != null) {
                l2val = l2.val;
            }
            currentNode.val = (l1val + l2val + flag) % 10;
            flag = (l1val + l2val + flag) / 10;
            pre.next = currentNode;
            pre = pre.next;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }

        if (flag > 0) {
            ListNode lastNode = new ListNode();
            lastNode.val = flag;
            pre.next = lastNode;
        }

        return dummyHead.next;
    }

    public static class ListNode {
        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }

        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }
}
```

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode();
        ListNode pre = dummyHead;
        while (l1 != null || l2 != null) {
            if (l1 == null) {
                pre.next = l2;
                l2 = l2.next;
                pre = pre.next;
                continue;
            }
            if (l2 == null) {
                pre.next = l1;
                l1 = l1.next;
                pre = pre.next;
                continue;
            }

            if (l1.val > l2.val) {
                pre.next = l2;
                l2 = l2.next;
            } else {
                pre.next = l1;
                l1 = l1.next;
            }
            pre = pre.next;
        }

        return dummyHead.next;
    }

    public static class ListNode {
        /**
         * 数组转list
         */
        public static ListNode array2List(int[] arr) {
            ListNode head = null;
            ListNode current = null;
            for (int index = 0; index < arr.length; index++) {
                if (head == null) {
                    head = new ListNode();
                    head.val = arr[index];
                    current = head;
                } else {
                    ListNode node = new ListNode();
                    node.val = arr[index];
                    current.next = node;
                    current = node;
                }
            }
            return head;
        }

        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

}
```

## 快慢指针

在获取倒数第n个链表元素的题中，需要先算出整个链表的长度

